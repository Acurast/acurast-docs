"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7196],{1515:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=r(8168),n=(r(6540),r(5680));r(1653),r(6025);const o={title:"Execution Layer",slug:"/acurast-protocol/architecture/execution-layer"},i=void 0,s={unversionedId:"acurast-protocol/architecture/execution-layer",id:"acurast-protocol/architecture/execution-layer",title:"Execution Layer",description:"Acurast's execution layer is modular, allowing the flexible selection of runtimes according to the requirements of the use-case and the deployment, respectively. Decoupling the execution layer from the consensus and application layer allows the long-term evolution of runtimes, avoiding dependency lock-ins. Additionally, it ensures the highest level of service and confidentiality because security models can iteratively evolve with upgrades as novel threats emerge or new requirements arise.",source:"@site/docs/acurast-protocol/architecture/execution-layer.mdx",sourceDirName:"acurast-protocol/architecture",slug:"/acurast-protocol/architecture/execution-layer",permalink:"/acurast-protocol/architecture/execution-layer",draft:!1,editUrl:"https://github.com/acurast/acurast-docs/docs/acurast-protocol/architecture/execution-layer.mdx",tags:[],version:"current",frontMatter:{title:"Execution Layer",slug:"/acurast-protocol/architecture/execution-layer"},sidebar:"docs",previous:{title:"Application Layer",permalink:"/acurast-protocol/architecture/application-layer"},next:{title:"Consensus Layer",permalink:"/acurast-protocol/architecture/consensus-layer"}},c={},l=[{value:"Acurast Secure Hardware Runtime (ASHR)",id:"acurast-secure-hardware-runtime-ashr",level:3},{value:"Rationale on using Mobile Hardware",id:"rationale-on-using-mobile-hardware",level:3},{value:"On TEEs and Hardware Security",id:"on-tees-and-hardware-security",level:3},{value:"Acurast Zero-Knowledge Runtime",id:"acurast-zero-knowledge-runtime",level:2},{value:"References",id:"references",level:4}],u={toc:l},p="wrapper";function d({components:e,...t}){return(0,n.yg)(p,(0,a.A)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("p",null,"Acurast's execution layer is modular, allowing the flexible selection of runtimes according to the requirements of the use-case and the ",(0,n.yg)("inlineCode",{parentName:"p"},"deployment"),", respectively. Decoupling the execution layer from the consensus and application layer allows the long-term evolution of runtimes, avoiding dependency lock-ins. Additionally, it ensures the highest level of service and confidentiality because security models can iteratively evolve with upgrades as novel threats emerge or new requirements arise."),(0,n.yg)("p",null,"Acurast offers native and straightforward bootstrapping of permissioned consortia. Depending on the requirements, either ",(0,n.yg)("em",{parentName:"p"},"(a)")," developers can directly leverage the Acurast orchestrator to select from a public pool of processors, or ",(0,n.yg)("em",{parentName:"p"},"(b)")," or use dedicated processors (",(0,n.yg)("em",{parentName:"p"},"e.g.,")," from trusted entities, or use developer-supported self-service processors). Such composability allows developers to customize access control and define individual trust models depending on the ",(0,n.yg)("inlineCode",{parentName:"p"},"deployments")," that are executed."),(0,n.yg)("p",null,"The Acurast execution layer natively offers two runtimes, the ",(0,n.yg)("em",{parentName:"p"},"(1)")," Acurast Secure Hardware Runtime (ASHR) and ",(0,n.yg)("em",{parentName:"p"},"(2)")," Acurast Zero-Knowledge Runtime (AZKR)."),(0,n.yg)("h3",{id:"acurast-secure-hardware-runtime-ashr"},"Acurast Secure Hardware Runtime (ASHR)"),(0,n.yg)("p",null,"The Acurast Secure Hardware Runtime (ASHR) is a generic approach to achieve a confidential execution layer while assuming a timely threat model, thus ensuring the highest possible level of security. The security guarantees achieved by secure hardware are generally highly divergent, from virtual processors to on-SoC processors, and finally, to the current bleeding edge of an ",(0,n.yg)("em",{parentName:"p"},"external coprocessor"),", which is a physically separated and independent chip, dedicated to only security-sensitive operations ",(0,n.yg)("a",{parentName:"p",href:"#references"},"[1]"),". The current ASHR implementation is based on coprocessors provided by the Google Titan chip ",(0,n.yg)("a",{parentName:"p",href:"#references"},"[2]"),". The Titan chip has not been compromised, unlike most secure hardware platforms. Although high-reward bug bounties",(0,n.yg)("a",{parentName:"p",href:"#references"},"[3]")," and the highest zero-day vulnerability payouts",(0,n.yg)("a",{parentName:"p",href:"#references"},"[4]")," do not ",(0,n.yg)("em",{parentName:"p"},"guarantee")," security, they are a solid indication of the security level achieved."),(0,n.yg)("h3",{id:"rationale-on-using-mobile-hardware"},"Rationale on using Mobile Hardware"),(0,n.yg)("p",null,"Smartphones are among the most complex cases when it comes to information security. Their computing power has grown to the point of being almost indistinguishable from computers, they store the most valuable personal data and are used to carry out security-sensitive activities, which make them extremely attractive targets for attackers. With such a wide-ranging threat model and the fact that the vast computing base of a modern OS cannot be fully trusted, vendors have begun to use hardware to improve the security of their systems ",(0,n.yg)("a",{parentName:"p",href:"#references"},"[1]"),"."),(0,n.yg)("h3",{id:"on-tees-and-hardware-security"},"On TEEs and Hardware Security"),(0,n.yg)("p",null,"Usually, Trusted Execution Environments (TEE) are created by integrating protection mechanisms directly into the processor or using dedicated external secure elements. However, both approaches only cover a narrow threat model, resulting in very limited security guarantees. For instance, enclaves nested in the application processor provide weak isolation and weak protection against side-channel attacks. Regardless of the approach used, TEEs often lack the ability to establish secure communication with peripherals, and most operating systems run inside TEEs do not provide state-of-the-art defense strategies, making them vulnerable to various attacks. Arguably, TEEs, such as Intel SGX ",(0,n.yg)("a",{parentName:"p",href:"#references"},"[5,6]")," or ARM TrustZone ",(0,n.yg)("a",{parentName:"p",href:"#references"},"[7]"),", implemented on the main application processor, are insecure, ",(0,n.yg)("em",{parentName:"p"},"particularly")," when considering side-channel attacks. For that reason, ASHR is based on the bleeding edge of a dedicated coprocessor."),(0,n.yg)("h2",{id:"acurast-zero-knowledge-runtime"},"Acurast Zero-Knowledge Runtime"),(0,n.yg)("p",null,"The Acurast ZKP-based Runtime (AZKR) is another approach towards achieving general-purpose verifiable computation by leveraging recursive ZKP, which can generate and aggregate proofs for any computation. While the ASHR provides a performance advantage over the AZKR, the trust model of ZK-based protocols draws its core trust assumptions from the cryptographic scheme, not hardware-based security assumptions. The ASHR can scale horizontally across different applications; the AZKR requires specific circuits, assumptions, and requirements. On the other hand, ASHR provides an isolated environment for sensitive code, optimized for efficiency. Finally, trust-wise, ASHR rely on key attestation procedures and hardware-based trust assumptions, while AZKR systems mainly rely on semi-trusted sequencers and the reliance on cryptographic soundness."),(0,n.yg)("h4",{id:"references"},"References"),(0,n.yg)("p",null,"[1]"," P. T. Maxime Rossi Bellom, Damiano Melotti, ",(0,n.yg)("em",{parentName:"p"},"2021: A Titan\nM Odyssey"),", 2021. Available on: ",(0,n.yg)("a",{parentName:"p",href:"https://i.blackhat.com/EU-21/Wednesday/EU-21-Rossi-Bellom-2021_A_Titan_M_Odyssey-wp.pdf"},"https://i.blackhat.com/EU-21/Wednesday/EU-21-Rossi-Bellom-2021_A_Titan_M_Odyssey-wp.pdf"),(0,n.yg)("br",{parentName:"p"}),"\n","[2]"," C. Wankhede, ",(0,n.yg)("em",{parentName:"p"},"What is the Titan M2 security chip in Google\u2019s Pixel phones?")," ",(0,n.yg)("a",{parentName:"p",href:"https://www.androidauthority.com/titan-m2-google-3261547/"},"https://www.androidauthority.com/titan-m2-google-3261547/"),", Jan 2023.",(0,n.yg)("br",{parentName:"p"}),"\n","[3]"," J. Reed, ",(0,n.yg)("em",{parentName:"p"},"Google\u2019s bug bounty hits $12 million: What about the risks?")," ",(0,n.yg)("a",{parentName:"p",href:"https://securityintelligence.com/news/googles-bug-bounty-hits-12-million-what-about-the-risks-2/"},"https://securityintelligence.com/news/googles-bug-bounty-hits-12-million-what-about-the-risks-2/"),", May 2023.",(0,n.yg)("br",{parentName:"p"}),"\n","[4]"," ZERODIUM, ",(0,n.yg)("em",{parentName:"p"},"ZERODIUM Payouts for Mobiles"),", ",(0,n.yg)("a",{parentName:"p",href:"https://zerodium.com/program.html"},"https://zerodium.com/program.html"),(0,n.yg)("br",{parentName:"p"}),"\n","[5]"," S. van Schaik, A. Kwong, and D. Genkin, ",(0,n.yg)("em",{parentName:"p"},"SGAxe: How SGX Fails in Practice"),", 2020. Available on: ",(0,n.yg)("a",{parentName:"p",href:"https://api.semanticscholar.org/CorpusID:220248073"},"https://api.semanticscholar.org/CorpusID:220248073"),(0,n.yg)("br",{parentName:"p"}),"\n","[6]"," S. van Schaik, A. Seto, T. Yurek, A. Batori, B. AlBassam, C. Garman, D. Genkin, A. Miller, E. Ronen, and Y. Yarom, ",(0,n.yg)("em",{parentName:"p"},"SoK: SGX. Fail: How stuff get eXposed"),", 2022.",(0,n.yg)("br",{parentName:"p"}),"\n","[7]"," S. Pinto and N. Santos, \u201cDemystifying Arm TrustZone: A Comprehensive Survey,\u201d ACM Computing Survey, Vol. 51, No. 6, Jan 2019. Available on\n",(0,n.yg)("a",{parentName:"p",href:"https://doi.org/10.1145/3291047"},"https://doi.org/10.1145/3291047")))}d.isMDXComponent=!0},5680:(e,t,r)=>{r.d(t,{xA:()=>u,yg:()=>m});var a=r(6540);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=a.createContext({}),l=function(e){var t=a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(r),h=n,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||o;return r?a.createElement(m,i(i({ref:t},u),{},{components:r})):a.createElement(m,i({ref:t},u))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:n,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"}}]);