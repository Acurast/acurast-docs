"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[433],{5120:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(8168),a=(t(6540),t(5680));const s={title:"Deployment Runtime Environment",slug:"/developers/deployment-runtime-environment"},i=void 0,o={unversionedId:"developers/deployment-runtime-environment",id:"developers/deployment-runtime-environment",title:"Deployment Runtime Environment",description:"The deployment's script running on Processors has access to the following a set of APIs.",source:"@site/docs/developers/deployment-runtime-environment.mdx",sourceDirName:"developers",slug:"/developers/deployment-runtime-environment",permalink:"/developers/deployment-runtime-environment",draft:!1,editUrl:"https://github.com/acurast/acurast-docs/docs/developers/deployment-runtime-environment.mdx",tags:[],version:"current",frontMatter:{title:"Deployment Runtime Environment",slug:"/developers/deployment-runtime-environment"},sidebar:"docs",previous:{title:"How to run an LLM on Acurast",permalink:"/developers/llm-on-acurast"},next:{title:"Deployments On Demand",permalink:"/developers/on-demand-deployments"}},c={},l=[{value:"<strong>Top level functions</strong>",id:"top-level-functions",level:2},{value:"<strong>The _STD_ object</strong>",id:"the-_std_-object",level:2},{value:"<strong>Random</strong>",id:"random",level:3},{value:"<strong>Environment Variables</strong>",id:"environment-variables",level:3},{value:"<strong>App Info</strong>",id:"app-info",level:3},{value:"<strong>Deployment Info</strong>",id:"deployment-info",level:3},{value:"<strong>Device Info</strong>",id:"device-info",level:3},{value:"<strong>Signers</strong>",id:"signers",level:3},{value:"<strong>Websocket</strong>",id:"websocket",level:3},{value:"<strong>P2P</strong>",id:"p2p",level:3},{value:"<strong>Substrate functions</strong>",id:"substrate-functions",level:3},{value:"<strong>Substrate signer functions</strong>",id:"substrate-signer-functions",level:3},{value:"<strong>Substrate codec functions</strong>",id:"substrate-codec-functions",level:3},{value:"<strong>Substrate contract functions</strong>",id:"substrate-contract-functions",level:3},{value:"<strong>Substrate Gear functions</strong>",id:"substrate-gear-functions",level:3},{value:"<strong>Tezos functions</strong>",id:"tezos-functions",level:3},{value:"<strong>Tezos encoding functions</strong>",id:"tezos-encoding-functions",level:3},{value:"<strong>Tezos message signing</strong>",id:"tezos-message-signing",level:3},{value:"<strong>Ethereum functions</strong>",id:"ethereum-functions",level:3},{value:"<strong>Ethereum message signing</strong>",id:"ethereum-message-signing",level:3},{value:"<strong>Ethereum ABI functions</strong>",id:"ethereum-abi-functions",level:3},{value:"<strong>Bitcoin functions</strong>",id:"bitcoin-functions",level:3},{value:"<strong>Bitcoin message signing</strong>",id:"bitcoin-message-signing",level:3},{value:"<strong>Bitcoin utils functions</strong>",id:"bitcoin-utils-functions",level:3},{value:"<strong>Aeternity functions</strong>",id:"aeternity-functions",level:3},{value:"<strong>Aeternity data encoding functions</strong>",id:"aeternity-data-encoding-functions",level:3}],g={toc:l},p="wrapper";function u({components:e,...n}){return(0,a.yg)(p,(0,r.A)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"The deployment's script running on Processors has access to the following a set of APIs."),(0,a.yg)("h2",{id:"top-level-functions"},(0,a.yg)("strong",{parentName:"h2"},"Top level functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Prints the given message to the console.\n * @param {string} message the message to print.\n */\nfunction print(message);\n\n/**\n * Performs an HTTP GET request.\n * @param {string} url the url to connect to.\n * @param {Record<string, string>} headers the request's headers, for example: { 'Accept': 'application/json' }.\n * @param {HttpSuccess} success the success callback function.\n * @param {HttpError} error the error callback function.\n */\nfunction httpGET(url, headers, success, error);\n\n/**\n * Performs an HTTP GET request.\n * @param {string} url the url to connect to.\n * @param {string} body a string representing the request's body.\n * @param {Record<string, string>} headers the request's headers, for example: { 'Content-Type': 'application/json' }.\n * @param {HttpSuccess} success the success callback function.\n * @param {HttpError} error the error callback function.\n */\nfunction httpPOST(url, body, headers, success, error);\n\n/**\n * @callback HttpSuccess\n * @param {string} payload the http request response payload as text.\n * @param {string} certificate a hex string representing the server certificate.\n */\ntype HttpSuccess = (payload, certificate) => void;\n\n/**\n * @callback HttpError\n * @param {string} message an error message.\n */\ntype HttpError = (message) => void;\n\n/**\n * Reads value from the environment.\n * @param {string} key The key used to get the value from the environment.\n * @return {string} The string value for the given key or undefined.\n */\nfunction environment(key);\n")),(0,a.yg)("h2",{id:"the-_std_-object"},(0,a.yg)("strong",{parentName:"h2"},"The ","_","STD","_"," object")),(0,a.yg)("p",null,"At the top level, a ",(0,a.yg)("inlineCode",{parentName:"p"},"_STD_")," object is defined. This object exposes additional functionalities."),(0,a.yg)("h3",{id:"random"},(0,a.yg)("strong",{parentName:"h3"},"Random")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Generates random bytes.\n * @return {string} Hex string representing random bytes.\n */\n_STD_.random.generateSecureRandomHex();\n")),(0,a.yg)("h3",{id:"environment-variables"},(0,a.yg)("strong",{parentName:"h3"},"Environment Variables")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * Environment object populated with the environment variables defined during deployment creation.\n * For example, to access a variable defined with the "MY_KEY" key do: _STD_.env["MY_KEY"].\n */\n_STD_.env;\n')),(0,a.yg)("h3",{id:"app-info"},(0,a.yg)("strong",{parentName:"h3"},"App Info")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * The processor app version as a string.\n *\n * Example: "1.9.2-canary"\n */\n_STD_.app_info.version;\n')),(0,a.yg)("h3",{id:"deployment-info"},(0,a.yg)("strong",{parentName:"h3"},"Deployment Info")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * @return {DeploymentId} Object representing a deployment id.\n *\n * Example:\n * {\n *  origin: {\n *    kind: "Acurast",\n *    source: "2273f64ccf6e9dc13aedf111ca19da030909374f18c6a958b8e5c64927dc7b4f"\n *  },\n *  id: "3510"\n * }\n */\n_STD_.job.getId();\n\ntype DeploymentId = { origin: { kind: string, source: string }, id: string };\n\n/**\n * @return {number} The slot number of this deployment.\n */\n_STD_.job.getSlot();\n\n/**\n * @return {PublicKeys} Object containing the deployment specific public keys.\n *\n * Example:\n * {\n *  p256: "03aa8fa2bfe5a5d6789637c3b82b322b617f8c19e29a4b7d3eede17a2583312891",\n *  secp256k1: "02fcf1a928bab608989a0218831efd585d1e771669756e1033c60cff4bef6f28e5",\n *  ed25519: "7ce9f9b96a0f898ad109a594ab2c30a1682e7e6425910427c9390fdf16b11dd6"\n * }\n */\n_STD_.job.getPublicKeys();\n\ntype PublicKeys = { p256: string, secp256k1: string, ed25519: string };\n')),(0,a.yg)("h3",{id:"device-info"},(0,a.yg)("strong",{parentName:"h3"},"Device Info")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Get the main account public key.\n *\n * @since 1.9.2 (version code 58)\n *\n * @return {string} Hex string representing the main account public key.\n */\n_STD_.device.getPublicKey();\n\n/**\n * Get the main account address.\n *\n * @since 1.9.2 (version code 58)\n *\n * @return {string} String representing the main account address.\n */\n_STD_.device.getAddress();\n")),(0,a.yg)("h3",{id:"signers"},(0,a.yg)("strong",{parentName:"h3"},"Signers")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Signs the given payload with the secp256r1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} payload Hex string representing the bytes to sign.\n * @return {string} Hex string representing the signature.\n */\n_STD_.signers.secp256r1.sign(payload);\n\n/**\n * Encrypts the given payload with the secp256r1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} publicKey Hex string representing the receiver's public key.\n * @param {string} salt Hex string representing the salt used for encryption.\n * @param {string} payload Hex string representing the bytes to encrypt.\n * @return {string} Hex string representing the encrypted payload.\n */\n_STD_.signers.secp256r1.encrypt(publicKey, salt, payload);\n\n/**\n * Decrypts the given payload with the secp256r1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} publicKey Hex string representing the sender's public key.\n * @param {string} salt Hex string representing the salt used for encryption.\n * @param {string} payload Hex string representing the bytes to decrypt.\n * @return {string} Hex string representing the decrypted payload.\n */\n_STD_.signers.secp256r1.decrypt(publicKey, salt, payload);\n\n/**\n * Signs the given payload with the secp256k1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} payload Hex string representing the bytes to sign.\n * @return {string} Hex string representing the signature.\n */\n_STD_.signers.secp256k1.sign(payload);\n\n/**\n * Encrypts the given payload with the secp256k1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} publicKey Hex string representing the receiver's public key.\n * @param {string} salt Hex string representing the salt used for encryption.\n * @param {string} payload Hex string representing the bytes to encrypt.\n * @return {string} Hex string representing the encrypted payload.\n */\n_STD_.signers.secp256k1.encrypt(publicKey, salt, payload);\n\n/**\n * Decrypts the given payload with the secp256k1 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n * \n * @param {string} publicKey Hex string representing the sender's public key.\n * @param {string} salt Hex string representing the salt used for encryption.\n * @param {string} payload Hex string representing the bytes to decrypt.\n * @return {string} Hex string representing the decrypted payload.\n */\n_STD_.signers.secp256k1.decrypt(publicKey, salt, payload);\n\n/**\n * Signs the given payload with the ed25519 key generated for the current deployment.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} payload Hex string representing the bytes to sign.\n * @return {string} Hex string representing the signature.\n */\n_STD_.signers.ed25519.sign(payload);\n")),(0,a.yg)("h3",{id:"websocket"},(0,a.yg)("strong",{parentName:"h3"},"Websocket")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {string | string[]} url to the acurast websocket service.\n * @param {WsSuccess} success the success callback.\n * @param {WsError} error the error callback.\n */\n_STD_.ws.open(url, success, error);\n\n/**\n * @param {WsSuccess} success the success callback.\n * @param {WsError} error the error callback.\n */\n_STD_.ws.close(success, error);\n\n/**\n * @param {WsHandler} handler the handler called on every incoming message.\n */\n_STD_.ws.registerPayloadHandler(handler);\n\n/**\n * @param {string} recipient the public key in hex format of the recipient.\n * @param {string} payload the payload to send as a hex string.\n * @param {WsSuccess} success the success callback.\n * @param {WsError} error the error callback.\n */\n_STD_.ws.send(recipient, payload, success, error);\n\n/**\n * @callback WsSuccess\n */\ntype WsSuccess = () => void;\n\n/**\n * @callback WsError\n * @param {string} message an error message.\n */\ntype WsError = (message) => void;\n\n/**\n * @callback WsHandler\n * @param {WsPayload} payload the payload message.\n */\ntype WsHandler = (payload) => void;\n\ntype WsPayload = { sender: string, recipient: string, payload: string };\n")),(0,a.yg)("h3",{id:"p2p"},(0,a.yg)("strong",{parentName:"h3"},"P2P")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {P2PConfig} config the node configuration.\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.start(config, success, error);\n\n/**\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.close(success, error);\n\n/**\n * @param {P2PMessageListener} listener the listener called on each incoming message.\n */\n_STD_.p2p.onMessage(listener);\n\n/**\n * @param {P2PPeer} receiver the peer who should receive the message.\n * @param {string} protocol the ID of the message protocol that should be used to transmit the message.\n * @param {string} bytes the payload to send as a hex string.\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.request(receiver, protocol, bytes, success, error);\n\n/**\n * @param {P2PMessage} request the request to which this message responds.\n * @param {string} bytes the payload to send as a hex string.\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.respond(request, bytes, success, error);\n\n/**\n * @param {string} peer the address or peer ID of the target peer to establish a connection with.\n * @param {P2PConnectOptions|undefined} options an optional configuration of this call.\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.connect(peer, options, success, error);\n\n/**\n * @param {string} peer the address or peer ID of the target peer whose connection should be terminated.\n * @param {P2PSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.disconnect(peer, success, error);\n\n/**\n * @param {string} peer the address or peer ID of the target peer to which the stream will be opened.\n * @param {string} protocol the protocol to be used for the stream.\n * @param {P2PStreamSuccess} success the success callback.\n * @param {P2PError} error the error callback.\n */\n_STD_.p2p.openOutgoingStream(peer, protocol, success, error);\n\n/**\n * @param {P2PStreamListener} listener the listener called on each incoming stream.\n */\n_STD_.p2p.onIncomingStream(listener);\n\n/**\n * @param {P2PConnectedRelayListener} listener the listener called whenever a relay is connected.\n */\n_STD_.p2p.onRelayConnected(listener);\n\n/**\n * @param {string} publicKey the public key from which the peer ID should be generated.\n * @return {string} the peer ID.\n */\n_STD_.p2p.peerIdFromPublicKey(publicKey): string;\n\n/**\n * @property {string[]} messageProtcols message protocols the node will support and use to send and receive messages.\n * @property {string[]} relays a list of public nodes that will serve as a proxy helping establish connections with nodes behind NATs and firewalls.\n * @property {number?} idleConnectionTimeout time in milliseconds after which idle connections will be closed, defaults to 15s if not provided.\n */\ntype P2PConfig = {\n  messageProtocols: string[]\n  relays: string[]\n  idleConnectionTimeout?: number\n};\n\n/**\n * @callback P2PSuccess\n */\ntype P2PSuccess = () => void;\n\n/**\n * @callback P2PStreamSuccess\n * @param {P2PStream} stream\n */\ntype P2PStreamSuccess = (stream) => void;\n\n/**\n * @callback P2PError\n * @param {string} message an error message.\n */\ntype P2PError = (message) => void;\n\n/**\n * @callback P2PMessageListener\n * @param {P2PMessage} message\n */\ntype P2PMessageListener = (payload) => void;\n\n/**\n * @property {number|string|undefined} timeout an optional duration in milliseconds for which the client will attempt to establish a connection with the peer. If the connection is being established through a relay, the client will wait for a direct connection within the timeout period. If unsuccessful, it will fallback to the relayed connection, if available.\n */\ntype P2PConnectOptions = {\n  timeout?: number | string\n}\n\n/**\n * @callback P2PStreamListener\n * @param {P2PStream} stream\n */\ntype P2PStreamListener = (stream) => void;\n\n/**\n * @callback P2PConnectedRelayListener\n * @param {string} address the address of the connected relay.\n */\ntype P2PConnectedRelayListener = (address) => void;\n\n/**\n * @property {P2PMessageType} type the type of the message.\n * @property {string} id internal id,\n * @property {P2Peer} sender the sender of the message.\n * @property {string} protocol the message protocol that was used to transmit this message.\n * @property {string} bytes the payload represented as a hex string.  \n */\ntype P2PMessage = { \n  type: P2PMessageType\n  id: string\n  sender: P2PPeer\n  protocol: string\n  bytes: string \n};\n\ntype P2PMessageType = 'request' | 'response';\n\ntype P2PPeer = { type: P2PPeerType, value: string };\ntype P2PPeerType = 'address' | 'peerId';\n\n/**\n * @property {string} protocol\n * @property {P2PPeer} peer\n * @function read reads n bytes from the stream.\n * @function write writes bytes to the stream.\n * @function close closes the stream.\n */\ntype P2PStream = {\n  protocol: string\n  peer: P2PPeer\n  read: P2PStreamRead\n  write: P2PStreamWrite\n  close: P2PStreamClose\n};\n\n/**\n * @function P2PStreamRead\n * @param {number} n the number of bytes to read from the stream.\n * @return {Promise<Buffer>} a promise that resolves with bytes read.\n */\ntype P2PStreamRead = (n) => Promise<Buffer>;\n\n/**\n * @function P2PStreamWrite\n * @param {Uint8Array | string} bytes the data to be written to the stream, provided as a `Uint8Array` or hex string.\n */\ntype P2PStreamWrite = (bytes) => Promise<void>;\n\n/**\n * @function P2PStreamClose\n */\ntype P2PStreamClose = () => Promise<void>;\n")),(0,a.yg)("h3",{id:"substrate-functions"},(0,a.yg)("strong",{parentName:"h3"},"Substrate functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Calls the `fulfill` extrinsic on the target substrate chain.\n * @param {string | string[]} nodes the node URL or array of node URLs.\n * @param {string} payload the string representation of the fulfill payload.\n * @param {object} extra an object with extra arguments. It needs to provide a `callIndex` which is the hex representation of the `fulfill` extrinsic's call index on the target substrate chain.\n * @param {SubstrateSuccess} success the success callback.\n * @param {SubstrateError} error the error callback.\n */\n_STD_.chains.substrate.fulfill(nodes, payload, extra, success, error);\n\n/**\n * @callback SubstrateSuccess\n * @param {string} operationHash the operation hash of the submitted extrinsic.\n */\ntype SubstrateSuccess = (operationHash) => void;\n\n/**\n * @callback SubstrateError\n * @param {string[]} message an error message.\n */\ntype SubstrateError = (message) => void;\n")),(0,a.yg)("h3",{id:"substrate-signer-functions"},(0,a.yg)("strong",{parentName:"h3"},"Substrate signer functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Sets the curve type to use when signing.\n * @param {'SECP256K1' | 'SECP256R1'} curveType\n */\n_STD_.chains.substrate.signer.setSigner(curveType);\n\n/**\n * Signs a payload.\n *\n * @since 1.9.2 (version code 58)\n *\n * @param {string} payload Hex string to sign.\n * @return {string} Hex string representing the signature.\n */\n_STD_.chains.substrate.signer.sign(payload);\n")),(0,a.yg)("h3",{id:"substrate-codec-functions"},(0,a.yg)("strong",{parentName:"h3"},"Substrate codec functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Hashes the given string using blake2b 256 bit.\n * @param {string} value\n * @return {string} The blake2b hash of the input value.\n */\n_STD_.chains.substrate.codec.blakeTwo256(value);\n\n/**\n * Encodes a number to the SCALE encoding.\n * @param {number | string} value the number to encode.\n * @param {8 | 32 | 64 | 128} bitSize the number's bit size.\n * @return {string} Hex string representing the SCALE encoded number.\n */\n_STD_.chains.substrate.codec.encodeUnsignedNumber(value, bitSize);\n\n/**\n * Encodes a number to the compact SCALE encoding.\n * @param {number | string} value the number to encode.\n * @return {string} Hex string representing the compact SCALE encoded number.\n */\n_STD_.chains.substrate.codec.encodeCompactUnsignedNumber(value);\n\n/**\n * Encodes bytes to SCALE encoding.\n * @param {string | ArrayBuffer} value hex string or an ArrayBuffer representing the bytes to encode.\n * @return {string} Hex string representing the SCALE encoded bytes.\n */\n_STD_.chains.substrate.codec.encodeBytes(value);\n\n/**\n * Encodes a boolean value to SCALE encoding.\n * @param {boolean} value the boolean value to encode.\n * @return {string} Hex string representing the SCALE encoded boolean.\n */\n_STD_.chains.substrate.codec.encodeBoolean(value);\n\n/**\n * Encodes a substrate address to SCALE encoding.\n * @param value the address to encode.\n * @return {string} Hex string representing the SCALE encoded address.\n */\n_STD_.chains.substrate.codec.encodeAddress(value);\n\n/**\n * Encodes a substrate address to a `MultiAddress` SCALE encoded vale.\n * @param value the address to encode.\n * @return {string} Hex string representing the SCALE encoded multi address.\n */\n_STD_.chains.substrate.codec.encodeMultiAddress(value: string);\n")),(0,a.yg)("h3",{id:"substrate-contract-functions"},(0,a.yg)("strong",{parentName:"h3"},"Substrate contract functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * Calls the `fulfill` extrinsic on a contract deployed on a chain integrating the substrate contract pallet (`pallet-contract`).\n * @param {string | stirng[]} nodes the node URL or array of node URLs.\n * @param {string} callIndex an hex string representing the call index of the `call` extrinsic of `pallet-contract`.\n * @param {string} destination the contract address.\n * @param {string} data the contract call arguments as an hex string.\n * @param {object} extra objet containing additional arguments, it has to at least provide `refTime` and `proofSize` as string values. Additionally it can provide a `value` as a string representing the amount to transfer with the contract call, `method` as a string representing the method name to use instead of `fulfill` and `storageDepositLimit` as a string value. Example: `{ refTime: "3951114240", proofSize: "629760" }`.\n * @param {SubstrateSuccess} success the success callback.\n * @param {SubstrateError} error the error callback.\n */\n_STD_.chains.substrate.contract.fulfill(\n  nodes,\n  callIndex,\n  destination,\n  data,\n  extra,\n  success,\n  error\n);\n\n/**\n * Calls the `fulfill` extrinsic on a contract deployed on a chain integrating the substrate contract pallet (`pallet-contract`).\n * @param {string | stirng[]} nodes the node URL or array of node URLs.\n * @param {string} method a string representing the method name to call on the destination contract.\n * @param {string} destination the contract address.\n * @param {string} data the contract call arguments as an hex string.\n * @param {object} extra objet containing additional arguments. It can provide a `blockNumber` as a string to sepcify at what lever to read from and `storageDepositLimit` as a string value.\n * @param {SubstrateSuccess} success the success callback.\n * @param {SubstrateError} error the error callback.\n */\n_STD_.chains.substrate.contract.callView(\n  nodes,\n  method,\n  destination,\n  data,\n  extra,\n  success,\n  error\n);\n')),(0,a.yg)("h3",{id:"substrate-gear-functions"},(0,a.yg)("strong",{parentName:"h3"},"Substrate Gear functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * Sends a message to an active Gear program extrinsic on a chain integrating the Gear protocol.\n * @param {string | stirng[]} nodes the node URL or array of node URLs.\n * @param {string} callIndex an hex string representing the call index of the `gear.sendMessage` extrinsic.\n * @param {string} destination the active program address.\n * @param {string} data an hex string encoding the method and arguments to call on the program.\n * @param {object} extra objet containing additional arguments, it has to provide `gasLimit` as a string, `value` as a string and `keepAlive` as a boolean. Example: `{ gasLimit: "2000000000", value: "0", keepAlive: true }`.\n * @param {SubstrateSuccess} success the success callback.\n * @param {SubstrateError} error the error callback.\n */\n_STD_.chains.substrate.gear.sendMessage(\n  nodes,\n  callIndex,\n  destination,\n  data,\n  extra,\n  success,\n  error\n);\n')),(0,a.yg)("h3",{id:"tezos-functions"},(0,a.yg)("strong",{parentName:"h3"},"Tezos functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Calls the `fulfill` entrypoint on the Tezos Acurast Proxy contract.\n * @param {string | string[]} nodes the node URL or array of node URLs.\n * @param {any} payload the second argument for the `fulfill` entrypoint call on the Acurast Proxy contract. It represents a Michelson value that will be packed to bytes.\n * @param {object} extra object with extra arguments, it has to at least provide the values for the `fee`, `gasLimit` and `storageLimit` as numbers. Additionally it can provide an `entrypoint` as a string to use instead of `fulfill`. Example: `{ fee: 1500, gasLimit: 3000, storageLimit: 0 }`.\n * @param {TezosSuccess} success the success callback.\n * @param {TezosError} error the error callback.\n */\n_STD_.chains.tezos.fulfill(nodes, payload, extra, success, error);\n\n/**\n * Calls a custom entrypoint on a Tezos contract.\n * @param {string | string[]} nodes the node URL or array of node URLs.\n * @param {any} payload a Michelson value representing the arguments of the entrypoint being called.\n * @param {object} extra object with extra arguments, it has to at least provide the values for the `fee`, `gasLimit` and `storageLimit` as numbers. Additionally it can provide an `entrypoint` as a string to use instead of `fulfill` and `destination` as a string for the contract address to use instead of the default Acurast Proxy contract. Example: `{ fee: 1500, gasLimit: 3000, storageLimit: 0 }`.\n * @param {TezosSuccess} success the success callback.\n * @param {TezosError} error the error callback.\n */\n_STD_.chains.tezos.customCall(nodes, payload, extra, success, error);\n\n/**\n * @callback TezosSuccess\n * @param {string} operationHash the operation hash of the submitted operation.\n */\ntype TezosSuccess = (operationHash) => void;\n\n/**\n * @callback TezosError\n * @param {string[]} message an error message.\n */\ntype TezosError = (message) => void;\n")),(0,a.yg)("h3",{id:"tezos-encoding-functions"},(0,a.yg)("strong",{parentName:"h3"},"Tezos encoding functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Packs the given micheline structure.\n * @param value an object representing a micheline structure.\n * @return {string} Hex string representing the packed value.\n */\n_STD_.chains.tezos.encoding.pack(value);\n\n/**\n * Encodes the given micheline structure into a hex value that can be used as key for big map values.\n * @param {object} value an object representing a micheline structure.\n * @return {string} Hex string representing the script hash encoded value.\n */\n_STD_.chains.tezos.encoding.encodeExpr(value);\n")),(0,a.yg)("h3",{id:"tezos-message-signing"},(0,a.yg)("strong",{parentName:"h3"},"Tezos message signing")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Signs the given message and returns the signature.\n *\n * Before signing, the message is prepended with the utf8 bytes of the\n * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message),\n * then the resulting bytes are hashed with blake2b256.\n *\n * @param {string} message an hex string representing the bytes to sign\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.tezos.signer.sign(message);\n")),(0,a.yg)("h3",{id:"ethereum-functions"},(0,a.yg)("strong",{parentName:"h3"},"Ethereum functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Calls `fulfill` on a ethereum contract.\n *\n * The `extra` argument is an object that can provide the following:\n * - `methodSignature`: an optional string representing the method signature, if not provided `fulfill(bytes)` is used.\n * - `gasLimit`: a string representing the transaction's gas limit, if not provided '9000000' is used.\n * - `maxPriorityFeePerGas`: a string representing the transaction's maxPriorityFeePerGas, if not provided '0' is used.\n * - `maxFeePerGas`: a string representing the transaction's maxFeePerGas, if not provided '0'.\n *\n * @param {string} url the node URL.\n * @param {string} destination the contract's address.\n * @param {string} payload a hex string representing the arguments for the method call.\n * @param {object} extra object with extra arguments.\n * @param {EthereumSuccess} success the success callback.\n * @param {EthereumError} error the success callback.\n */\n_STD_.chains.ethereum.fulfill(url, destination, payload, extra, success, error);\n\n/**\n * @callback EthereumSuccess\n * @param {string} operationHash the operation hash of the submitted operation.\n */\ntype EthereumSuccess = (operationHash) => void;\n\n/**\n * @callback EthereumError\n * @param {string[]} message an error message.\n */\ntype EthereumError = (message) => void;\n\n/**\n * @return {string} The processor's ethereum address for the current deployment.\n */\n_STD_.chains.ethereum.getAddress();\n")),(0,a.yg)("h3",{id:"ethereum-message-signing"},(0,a.yg)("strong",{parentName:"h3"},"Ethereum message signing")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Signs the given message and returns the signature.\n *\n * Before signing, the message is prepended with the utf8 bytes of the\n * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message),\n * then the resulting bytes are hashed with Keccak256.\n *\n * @param {string} message an hex string representing the bytes to sign\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.ethereum.signer.sign(message);\n")),(0,a.yg)("h3",{id:"ethereum-abi-functions"},(0,a.yg)("strong",{parentName:"h3"},"Ethereum ABI functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Encodes the given value.\n *\n * @param {any} value A string, number or an array/object containing strings and numbers.\n * @return {string} Hex string representing the encoded value.\n */\n_STD_.chains.ethereum.abi.encode(value);\n\n/**\n * Encodes a numeric value.\n *\n * @param {number|string} value A number or a hex string representing a big integer.\n * @param {number} bitLength A number specifying the bit length.\n * @param {boolean} isNatural A boolean indicating if it is a natural number.\n * @return {string} Hex string representing the encoded value.\n */\n_STD_.chains.ethereum.abi.encodeNumeric(value, bitLength, isNatural);\n\n/**\n * Encodes an objects as a structure.\n *\n * @param {any} value A string, number or an array/object containing strings and numbers.\n * @param {boolean} isDynamic A boolean indicating if it is a dynamic strucure.\n * @return {string} Hex string representing the encoded value.\n */\n_STD_.chains.ethereum.abi.encodeStruct(value, isDynamic);\n")),(0,a.yg)("h3",{id:"bitcoin-functions"},(0,a.yg)("strong",{parentName:"h3"},"Bitcoin functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * Returns the public key for the bitcoin chain.\n *\n * @since 1.5.0 (version code 28)\n *\n * @return {string} Hex string representing the public key\n */\n_STD_.chains.bitcoin.getPublicKey();\n\n/**\n * Returns an extended public key for the given derivation path.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} version an hex string representing the bytes that will be prepended to the extended public key bytes before the base58check encoding\n * @param {string} derivationPath the derivation path to use. Currently, the only valid value is "m/0/1".\n * @return {string} String representing the extended public key\n */\n_STD_.chains.bitcoin.getExtendedPublicKey(version, derivationPath);\n')),(0,a.yg)("h3",{id:"bitcoin-message-signing"},(0,a.yg)("strong",{parentName:"h3"},"Bitcoin message signing")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Signs the given message and returns the signature.\n *\n * Before signing, the message is prepended with the utf8 bytes of the\n * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message).\n *\n * @since 1.4.0 (version code 26)\n *\n * @param {string} message an hex string representing the bytes to sign\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.bitcoin.signer.sign(message);\n\n/**\n * Signs the given message and returns the signature.\n *\n * @since 1.4.0 (version code 26)\n *\n * @param {string} message an hex string representing the bytes to sign\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.bitcoin.signer.rawSign(message);\n\n/**\n * Hashes the given value using SHA256.\n *\n * @since 1.4.0 (version code 26)\n *\n * @param {string} value an hex string representing the bytes to hash\n * @return {string} Hex string representing the sha256 hash\n */\n_STD_.chains.bitcoin.signer.sha256(value);\n\n/**\n * Signs the given message with a key derived with the given derivation path and returns the signature.\n *\n * Before signing, the message is prepended with the utf8 bytes of the\n * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message).\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} message an hex string representing the bytes to sign\n * @param {string} derivationPath the derivation path to use. Currently, the only valid value is \"m/0/1\"\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.bitcoin.signer.signHD(message, derivationPath);\n\n/**\n * Signs the given message with a key derived with the given derivation path and returns the signature.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} message an hex string representing the bytes to sign\n * @param {string} derivationPath the derivation path to use. Currently, the only valid value is \"m/0/1\"\n * @return {string} Hex string representing the signature\n */\n_STD_.chains.bitcoin.signer.rawSignHD(message, derivationPath);\n")),(0,a.yg)("h3",{id:"bitcoin-utils-functions"},(0,a.yg)("strong",{parentName:"h3"},"Bitcoin utils functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Derives the given extended public key.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} xpub a string representing the extended public key to derive\n * @param {string} derivationPath the derivation path to use\n * @return {string} Hex string representing the derivced public key\n */\n_STD_.chains.bitcoin.utils.derivePublicKey(xpub, derivationPath);\n\n/**\n * Encodes the given bytes using base58check.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} value an hex string representing the bytes to encode\n * @return {string} The base58check encoded value\n */\n_STD_.chains.bitcoin.utils.base58CheckEncode(value);\n\n/**\n * Encodes the given bytes using base58.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} value an hex string representing the bytes to encode\n * @return {string} The base58 encoded value\n */\n_STD_.chains.bitcoin.utils.base58Encode(value);\n\n/**\n * Decodes the given base58check value.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} value a string representing the base58check value to decode\n * @return {string} Hex string representing the decoded value\n */\n_STD_.chains.bitcoin.utils.base58CheckDecode(value);\n\n/**\n * Decodes the given base58 value.\n *\n * @since 1.7.0 (version code 38)\n *\n * @param {string} value a string representing the base58 value to decode\n * @return {string} Hex string representing the decoded value\n */\n_STD_.chains.bitcoin.utils.base58Decode(value);\n")),(0,a.yg)("h3",{id:"aeternity-functions"},(0,a.yg)("strong",{parentName:"h3"},"Aeternity functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Calls `fulfill` on an aeternity contract.\n *\n * The `extra` argument is an object that can provide the following:\n * - `functionName`: an optional string representing the method name, if not provided `fulfill` is used.\n * - `gasLimit`: a string representing the transaction's gas limit, if not provided '25000' is used.\n * - `gasPrice`: a string representing the transaction's gas price, if not provided '1000000000' is used.\n *\n * @since 1.3.32\n *\n * @param {string} url the node URL.\n * @param {string} destination the contract's address.\n * @param {[object]} payload an array of encoded values. The objects inside this array need to be constructed using the functions found under `_STD_.chains.aeternity.data`.\n * @param {object} extra object with extra arguments.\n * @param {AeternitySuccess} success the success callback.\n * @param {AeternityError} error the success callback.\n */\n_STD_.chains.aeternity.fulfill(\n  url,\n  destination,\n  payload,\n  extra,\n  success,\n  error\n);\n\n/**\n * Returns the Aeternity address.\n *\n * @since 1.3.34 (version code 19)\n *\n * @return {string} The Aeternity address\n */\n_STD_.chains.aeternity.getAddress();\n\n/**\n * @callback EthereumSuccess\n * @param {string} operationHash the operation hash of the submitted operation.\n */\ntype AeternitySuccess = (operationHash) => void;\n\n/**\n * @callback EthereumError\n * @param {string[]} message an error message.\n */\ntype AeternityError = (message) => void;\n")),(0,a.yg)("h3",{id:"aeternity-data-encoding-functions"},(0,a.yg)("strong",{parentName:"h3"},"Aeternity data encoding functions")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-javascript"},'/**\n * Returns an object representing an integer that can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {number | string} value a value representing an integer.\n * @return {object} an object representing an integer that can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.int(value);\n\n/**\n * Returns an object representing a string that can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {string} value a string value.\n * @return {object} an object representing a string that can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.string(value);\n\n/**\n * Returns an object representing bytes that can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {string} value an hex string representing the bytes.\n * @return {object} an object representing bytes that can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.bytes(value);\n\n/**\n * Returns an object representing a list of objects that can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {object[]} values an array of objects that were created using the functions found under `_STD_.chains.aeternity.data`.\n * @return {object} an object representing a list of objects that can be used as payload in the `fulfill` call\n */\n_STD_.chains.aeternity.data.list(values);\n\n/**\n * Returns an object representing a tuple can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {object[]} values an array of objects that were created using the functions found under `_STD_.chains.aeternity.data`.\n * @return {object} an object representing a tuple can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.tuple(values);\n\n/**\n * Returns an object representing a map can be used as payload in the `fulfill` call.\n *\n * The input value is an array of arrays of objects. The items need to be an array of size 2,\n * where the first element represents a map key and the second element represents its value:\n *\n * _STD_.chains.aeternity.data.map([\n *  [_STD_.chains.aeternity.data.string("key1"), _STD_.chains.aeternity.data.string("value1")],\n *  [_STD_.chains.aeternity.data.string("key2"), _STD_.chains.aeternity.data.string("value2")]\n * ]);\n *\n * @since 1.3.32\n *\n * @param {object[][]} values an array of arrays of objects that were created using the functions found under `_STD_.chains.aeternity.data`.\n * @return {object} an object representing a map can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.map(values);\n\n/**\n * Returns an object representing an account pubkey can be used as payload in the `fulfill` call.\n *\n * @since 1.3.32\n *\n * @param {string} value a string representing an account pubkey .\n * @return {object} an object representing an account pubkey can be used as payload in the `fulfill` call.\n */\n_STD_.chains.aeternity.data.account_pubkey(value);\n')))}u.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>h});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach(function(n){a(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},g=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef(function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),p=l(t),d=a,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||s;return t?r.createElement(h,i(i({ref:n},g),{},{components:t})):r.createElement(h,i({ref:n},g))});function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=d;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o[p]="string"==typeof e?e:a,i[1]=o;for(var l=2;l<s;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"}}]);