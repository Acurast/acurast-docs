# Acurast Documentation

> Complete reference documentation for Acurast

This file contains all documentation content in a single document following the llmstxt.org standard.

## Acurast Orchestrator

The Acurast Orchestrator is a centerpiece of the consensus layer, combining the orchestration (i.e., the scheduling of deployments and enabling the liquid matching) of the Processor’s computational resources and Developers. The orchestrator plays an essential role in the definition, agreement, and enforcement of value exchange between processors and developers.

The orchestrator is where the liquid matching engine pairs the advertised processor resources with the defined requirements of the developers. The orchestrator natively supports various price-finding mechanisms (e.g., auctions and advertisements), making DevEx highly accessible and seamless.

Every agreement between processor and developer is specified in an entity called deployment. The deployment specifies (i) a set of instructions that are executed on the processor, (ii) its scheduling parameters, and (iii) settlement configuration (i.e., where the output is further processed or persisted), and (iv) finally, the rewards.

**The orchestrator reward is a core mechanism of the Acurast Protocol, formed by two flows**

1. The compute/data flow
1. The reward flow

<ThemedImage
  alt="Docusaurus themed image"
  sources={{
    light: useBaseUrl("/img/acurast-orchestrator-flows_light.svg"),
    dark: useBaseUrl("/img/acurast-orchestrator-flows_dark.svg"),
  }}
/>

## Compute/Data Flow

For example, data can be the observation of a public data point (e.g., from a public API), an off-chain computation, the privacy-preserving querying of proprietary data (i.e., permissioned data), or even a combination of all these subcases. From the DevEx and developer’s perspective, it can be compared to defining requirements with a public cloud provider like e.g., Amazon Web Services, Google Cloud or Microsoft Azure.

## Reward Flow

For the reward flow, the developer defines the budget for the execution of the specified deployment. The budget can be defined in native ACU tokens, or for example, FIAT-pegged stablecoins. This mechanism allows for deterministic financial planning of executions for both the processor andthe developer. The processor automatically receives the reward upon successful execution of deployments.

---

## Application Layer

In the Internet of today, almost every application relies heavily on auxiliary systems. Whether external APIs are used for authentication, basic infrastructure (hosting), data availability, reliance, which can benefit from extending or replacing services and core elements with confidential applications, essentially eliminating a host of threat events. The possibilities with Acurast are near-endless since today's centralized Internet is heavily centralized both logically and in terms of trust anchors.

## Use Case Examples

Acurast's architecture transforms the way applications are designed and deployed. Acurast achieves an unparalleled Developer Experience (DevEx) by offering the [Acurast Hub](https://hub.acurast.com) to developers, where a self-service model allows developers to integrate and develop their applications. The following subsections outline potential algorithms and use-cases that can be deployed in a confidential manner through Acurast.

### Zero-Knowledge Proof Applications

Zero-Knowledge Proof protocols find vast application in blockchains [[1]](#references). Potential use cases range from anonymous voting systems [[2]](#references), to secure and privacy-preserving digital assets exchange, secure remote biometric authentication, or Proof-of-Reserves [[3]](#references).

Acurast can be leveraged in multiple areas of ZKP applications, for instance, to offload high intensity computation in a confidential manner [[4]](#references), or to form sub-consortia of processors that can, for instance, mix and generate proofs that the mixing has been performed correctly.

### Privacy-Preserving Mixing

With ZKPs, privacy mixing can occur in a way that allows transactions to be validated without exposing the details of those transactions. However, the mixing is not limited to Web3 transactions and can be extended to other data sensitive to privacy (_e.g.,_ metadata of internet traffic or metadata of files).

### Secure Multi-Party Computation

Secure Multi-Party Computation (SMPC) is a cryptographic primitive that enables distributed parties to conduct joint computations without revealing their own private inputs and outputs to the computation [[7]](#references). For instance, doctors may query a database containing private information, or banks may invest in a fund that must satisfy both banks private constraints. Usually, one trusted entity must know the inputs from all the participants, however, if no Trusted Third Party (TTP) is available or suitable, privacy concerns are evident [[7]](#references). With Acurast, a processors can be selected for SMPC algorithms to execute _e.g.,_ a permissionless poker game [[8]](#references).

### Blockchain Infrastructure

Blockchain networks' rising adoption and complexity of blockchain networks has led to an increasing need for a reliable blockchain infrastructure. Novel incentive structures (_e.g.,_ slashing in PoS) have intensified this further. It is crucial that this infrastructure is neither logically nor physically centralized because it would introduce new trust assumptions that undermine the permissionless nature of blockchains. For these services, Acurast can serve as a decentralized, serverless backend.

### Incorruptible Sequencer

A huge issue in public blockchains is Blockchain Extractable Value (BEV), and Miner Extractable Value (MEV), where DeFi users are at risk of being attacked [[9]](#references) (_e.g.,_ frontrunning and sandwich attacks [[10]](#references). With Acurast, processors can serve as confidential and confidential sequencers, ensuring that the order of transactions is deterministic and immune to external influence.

### Beyond Oracles: Serverless Applications

Oracles and on-chain automation are key ingredients of blockchain infrastructure. While oracles enable external data to be imported into the blockchain, oracles mainly deal with data retrieval and validation, ensuring that accurate and reliable data is fed into smart contracts. However, on-chain automation has a broader scope, encompassing automated liquidity provision, periodic settlements, debt restructuring, yield harvesting, and much more. The emphasis here is on action and execution based on specific conditions.
On-chain automation is about executing predefined actions without manual intervention, based on conditions or triggers that may come from oracles or on-chain data and events.

### Native Cross-Chain DeFi

Native cross-chain DeFi capabilities have been developed to allow seamless interactions and transactions between blockchains, creating a more inclusive and expansive financial ecosystem. Applying Account Abstraction allows for the design of accounts that can interact and integrate across various platforms and protocols, simplifying user experiences and opening the door for innovative use cases.

### Data Availability as-a-Service

(DAaaS) provides decentralized storage solutions to ensure data remains accessible and intact, fortifying the robustness of the entire decentralized ecosystem.

### Decentralized Scraping Infrastructure

Of all the Internet traffic in 2022, 47.4 % was automated traffic, also commonly referred to bots [[5]](#references). Of that automated traffic, 30.2 % were bad bots, while good bots are on the rise too, accounting for 17.3 %. The percentage of human traffic continues its downward trend, from 57.7 % in 2021 to 52.6 % in 2022. Bots, in that context do not refer to volumetric Distributed Denial-of-Service attacks, but the bot activity on layer 7 of the OSI model. In general, good bots are important for various business models and applications, since they are scraping data and feed models for decision making or business logic directly.

With Acurast, the scraping infrastructure can be fully decentralized logically and physically, leveraging the network of processor resources that confidentially execute these tasks, without leaking any data about the querying party. For example, when intelligence is gathered (_e.g.,_ for investment or merger decisions), a large amount of data must be scraped confidentially.

### Artifical Intelligence

The recent surge of Artificial Intelligence (AI) applications has led to increased research and development in these areas. While the potential of these technologies are vast, the risks associated to the centralized deployment and privacy of data is crucial to assess carefully. In Acurast, the _Singularity_ module allows the execution of AI in a decentralized and confidential fashion. _E.g.,_ Acurast enables Large Language Models (LLM) to be executed in a federated, privacy-preserving, and trustless way [[11]](#references).

### Internet of Things

In general terms, the Internet of Things (IoT) refers to interconnected computing devices that form a network and monitor environmental variables (_e.g.,_ health care [[12]](#references). Often, due to its limited resources, heterogeneity, and lack of computing power, IoT faces many security and privacy challenges. Data is transferred between IoT devices without human intervention, making confidentiality an essential aspect in network and trust management. The Acurast _Mesh_ module creates space for novel IoT use cases. Depending on the processor used, built-in Bluetooth modules or WiFi direct connections can be used to collect metrics or data and confidentially process the data.

#### References

[1] X. Sun, F. R. Yu, P. Zhang, Z. Sun, W. Xie, and X. Peng, _A Survey on Zero-Knowledge Proof in Blockchain,_ IEEE Network, Vol. 35, No. 4, pp. 198–205, 2021.  
[2] C. Killer, M. Eck, B. Rodrigues, J. von der Assen, R. Staubli, and B. Stiller, _ProvotuMN: Decentralized, Mix-Net-based, and Receipt-free Voting System,_ in 2022 IEEE International Conference on Blockchain and Cryptocurrency (ICBC), 2022, pp. 1–9.  
[3] C. Killer, B. Rodrigues, E. J. Scheid, M. F. Franco, and B. Stiller, _Blockchain-based Voting Considered Harmful?_ IEEE Transactions on Network and Service Management, pp. 1–1, 2022.  
[4] N. Ni and Y. Zhu, _Enabling Zero Knowledge Proof by Accelerating zk-SNARK Kernels on GPU,_ Journal of Parallel and Distributed Computing, vol. 173, pp. 20–31, 2023.  
[5] Imperva, “Imperva 2023 Bad Bot Report,” https://www.imperva.com/resources/resource-library/reports/2023-imperva-bad-bot-report/, May, 2023.  
[6] D. C. Nguyen, M. Ding, P. N. Pathirana, A. Seneviratne, J. Li, and H. V. Poor, _Federated Learning for Internet of Things: A Comprehensive Survey,_ IEEE Communications Surveys and Tutorials, Vol. 23, No. 3, pp. 1622–1658, 2021.  
[7] W. Du and M. J. Atallah, _Secure Multi-Party Computation Problems and Their Applications: A Review and Open Problems,_ in Proceedings of the 2001 Workshop on New Security Paradigms, ser. NSPW ’01. New York, NY, USA: Association for Computing Machinery, 2001, p. 13–22. Available on: https://doi.org/10.1145/508171.508174  
[8] R. Kumaresan, T. Moran, and I. Bentov, “How to use bitcoin to play decentralized poker,” in Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Ser. CCS ’15. New York, NY, USA: Association for Computing Machinery, 2015, p. 195–206. [Online]. Available on: https://doi.org/10.1145/2810103.2813712  
[9] L. Zhou, X. Xiong, J. Ernstberger, S. Chaliasos, Z. Wang, Y. Wang, K. Qin, R. Wattenhofer, D. Song, and A. Gervais, _SoK: Decentralized Finance (DeFi) Attacks,_ 2023  
[10] P. Daian, S. Goldfeder, T. Kell, Y. Li, X. Zhao, I. Bentov, L. Breidenbach, and A. Juels, _Flash Boys 2.0: Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges_, 2019.  
[11] D. C. Nguyen, M. Ding, P. N. Pathirana, A. Seneviratne, J. Li, and H. V. Poor, _Federated Learning for Internet of Things: A Comprehensive Survey,_ IEEE Communications Surveys and Tutorials, vol. 23, no. 3, pp. 1622–1658, 2021.  
[12] S. B. Baker, W. Xiang, and I. Atkinson, _Internet of Things for Smart Healthcare: Technologies, Challenges, and Opportunities,_ IEEE Access, Vol. 5, pp. 26 521–26 544, 2017.

---

## Overview

Acurast separates the consensus, execution, and application layer (c.f., Fig. 1).
Acurast's cloud architecture transforms the way applications are designed and deployed. The modular nature allows native settlements and universal interoperability of ecosystems, i.e., Web3 → Web3 and Web3 → Web2. Ultimately, Acurast serves as a decentralized application platform that ensures the privacy and verifiability of data, without introducing new trusted entities.

<ThemedImage
  width="300px"
  sources={{
    light: useBaseUrl("/img/architecture.svg"),
    dark: useBaseUrl("/img/architecture.svg"),
  }}
/>

  Figure 1: Acurast Architecture{" "}

### Consensus Layer

The consensus layer is the permissionless foundation of Acurast, where the Orchestrator matches developer's deployments to processors, as outlined in the End-to-End flow (_c.f.,_ [End-to-End Deployment Execution](/acurast-protocol/architecture/end-to-end) ). The second core part of the consensus layer is the reputation engine (_c.f.,_ ), which as sures that the reputation scores of processors are correctly updated and incentivize honest behavior.

### Execution Layer

The Execution Layer has two significant components. The first one is composed of the different processor runtimes, namely the Acurast Secure Hardware Runtime (_c.f.,_ [ASHR](/acurast-protocol/architecture/execution-layer#acurast-secure-hardware-runtime-ashr)) and the Acurast Zero-Knowledge Runtime (_c.f.,_ [AZKR](/acurast-protocol/architecture/execution-layer#acurast-zero-knowledge-runtime)). The second key component is the Acurast Universal Interoperability Layer, which contains multiple Modules that enable native interaction with different ecosystems.

### Application Layer

The third layer is the application layer, where Web2 or Web3 applications run (\cf Sec.~\ref{sec:application_layer}). Although a host of DeFi protocols already make use of Acurast, Acurast will infuse the development of a wide range of use cases that were previously not possible to implement in a confidential and decentralized manner.

## Implementation

Acurast leverages a Substrate Runtime consisting of multiple Substrate Pallets for the Acurast Protocol (_c.f.,_ [GitHub](https://github.com/acurast) ).

---

## Consensus Layer

The Permissionless Consensus layer forms the base of the Acurast protocol and is based on a variant of the Nominated Proof-of-Stake (NPoS) algorithm [[1]](#references). Unlike traditional Proof-of-Stake (PoS) networks, there are *validators* and *nominators* in NPoS. Block validators verify transactions to be included in the next block, similar to traditional PoS block validators. The key difference is that instead of being randomly chosen, the *validator* nodes are *nominated* by another node. 

In Acurast's NPoS, an unlimited amount of token holders can participate as *nominators*, backing a limited set of *validators* with their stake. Having a limited set of *validators* assures the long-term scalability of the consensus, allowing the increase of the maximum threshold through governance decisions. An unlimited set of *nominators* assure that higher value is at stake, assuring a high level of security. Due to its upgradable runtimes, consensus parameters are configurable by governance decisions, *e.g.,* The maximum number of *validators*, and the minimum amount of stake for *validators*. 

The Acurast NPoS system heavily leverages nominators to ensure network integrity. Nominators and validators have multiple aligned incentives. Nominators hold a financial stake in the system, which means that they could suffer a loss if a validator acts maliciously. In addition, nominators are financially rewarded for selecting a reliable and high-performance validator. Both nominators and validators have reputational stakes, with the credibility of nominators affected by their validator choices. Finally, the limited number of validator slots in NPoS structures creates a competitive environment, pushing nominators to select the most efficient validators, but also democratizes the process, making voting power essential.

NPoS has proven to be an efficient way to achieve high levels of security, scalability, and decentralization over time. Congruent to [[1]](#references), nominators share the rewards, or eventual slashings, with the validators they nominated on a *per-staked-ACU* basis. 

#### References 

[1] J. Burdges, A. Cevallos, P. Czaban, R. Habermeier, S. Hosseini, F. Lama, H. K. Alper, X. Luo, F. Shirazi, A. Stewart, and G. Wood, *Overview of Polkadot and its Design Considerations,* 2020.

---

## End-to-End Deployment Execution

Acurast introduces a paradigm shift in verifiable and confidential computation, advancing the way decentralized applications are developed and deployed. To emphasize the inner workings of Acurast, the following description follows a `deployment` from definition and deployment to completion (_c.f.,_ Fig. 1).

<ThemedImage
  width="800px"
  sources={{
    light: useBaseUrl("/img/end-to-end_light.svg"),
    dark: useBaseUrl("/img/end-to-end_dark.svg"),
  }}
/>

  Figure 1: End-to-End Deployment Execution{" "}

### (1) `Deployment` Registration

As a first step, developers define their `deployment` details. For example, at what destination the `deployment` should be _settled_, i.e., on which protocol the `deployment` output should be persisted (e.g., on Bitcoin Mainnet). After that, the developer can select `ready-to-deploy` templates, which can be adapted and changed to the developer's needs, or a custom `deployment` can be defined.

Depending integration level of the destination ecosystem with Acurast, the pre-payments for gas fees and rewards are settled in the native currency the developer prefers (e.g., native TEZ for Tezos or ETH for Ethereum) or in native Acurast ACU tokens.

Next, the developer must state on which processors the `deployment` should be executed, either (a) on personal processors, or (b) on selected, known processors (e.g., known trusted entities), or (c) on public processors. For (a), a processor reward is not required, since it is a permissioned setting. For (b) a reward is optional, and for (c) the liquid matching engine and the Acurast orchestrator will match processor resources with developers' `deployment`s.

In addition, more details of the `deployment` need to be declared, such as _scheduling_ parameters, including start time, end time, the interval between executions, as well as the duration in milliseconds and the maximum start delay in milliseconds. Furthermore, specific resource management parameters, such as memory usage, network requests, and storage requirements of the `deployment` need to be declared. Finally, the reward for the execution of the `deployment` should be declared, as well as the minimum reputation (only applies to (c) public processors). Then the `deployment` will be persisted on the Acurast Consensus Layer and reaches `OPEN` state (c.f., Fig. 2).

<ThemedImage
  width="400px"
  sources={{
    light: useBaseUrl("/img/deployment-states-light.svg"),
    dark: useBaseUrl("/img/deployment-states-dark.svg"),
  }}
/>

  Figure 2: States of a deployment{" "}

### (2) `Deployment` Acknowledgment

Second, the processor acknowledges the `deployment` and fetches the details from the Acurast chain. Depending on the fulfillment definition of the respective `deployment`, the Merkle root of the `deployment` with proof of assignment is persisted on the target destination (e.g., on a different target chain). Now the `deployment` reaches the `MATCHED` state, and no other processors will attempt to acknowledge it.

A prerequisite for assigning the `deployment` to the processor is that the processor can execute the `deployment` in full, following the _all-or-nothing_ principle. Since `deployment`s can have different scheduling configurations (e.g., on demand, every minute, etc.). Therefore, if the processor acknowledges that all slots can be adhered to, the `deployment` reaches the `ASSIGNED` state.

### (3) `Deployment` Execution

Next, the `deployment_script` is executed in the processor runtime. In the illustrated example of Fig. 1, the execution is performed inside of the Acurast Secure Hardware Runtime (ASHR), _i.e.,_ because _confidentiality_ is ascertained by secure hardware _e.g.,_ an isolated and external coprocessor (Google's Titan M2 Chip). Other runtimes (e.g., the Acurast Zero-Knowledge Runtime (AZKR)) may provide additional soundness guarantees.

### (4) `Deployment` Fulfillment

\textbf{(4) `deployment` Fulfillment:} Once the `deployment` execution is completed, the output is delivered to the declared destination, which could be another Web3 system (e.g., Tezos, Ethereum) or a Web2 system (e.g., REST-API, FL model) that receives the output. In case of a cross-chain transaction, the processor settles the gas fees on the destination chain, since the developer has locked the necessary reward and gas fee amount up front when registering the `deployment`.

### (5) `Deployment` Reporting

After completion, the processor reports back to the Acurast Consensus Layer, more specifically to the reputation engine. If fulfillment was successful, the report contains a transaction hash of the target chain containing the fulfillment transaction. In case of failure, the report contains error messages. Finally, the `deployment` is now in `DONE` state.

To assure the reliability of the Acurast protocol, the reputation engine is continuously fed with reliability metrics, for instance right after `deployment` completion or failure.

---

## Execution Layer

Acurast's execution layer is modular, allowing the flexible selection of runtimes according to the requirements of the use-case and the `deployment`, respectively. Decoupling the execution layer from the consensus and application layer allows the long-term evolution of runtimes, avoiding dependency lock-ins. Additionally, it ensures the highest level of service and confidentiality because security models can iteratively evolve with upgrades as novel threats emerge or new requirements arise.

Acurast offers native and straightforward bootstrapping of permissioned consortia. Depending on the requirements, either _(a)_ developers can directly leverage the Acurast orchestrator to select from a public pool of processors, or _(b)_ or use dedicated processors (_e.g.,_ from trusted entities, or use developer-supported self-service processors). Such composability allows developers to customize access control and define individual trust models depending on the `deployments` that are executed.

The Acurast execution layer natively offers two runtimes, the _(1)_ Acurast Secure Hardware Runtime (ASHR) and _(2)_ Acurast Zero-Knowledge Runtime (AZKR).

### Acurast Secure Hardware Runtime (ASHR)

The Acurast Secure Hardware Runtime (ASHR) is a generic approach to achieve a confidential execution layer while assuming a timely threat model, thus ensuring the highest possible level of security. The security guarantees achieved by secure hardware are generally highly divergent, from virtual processors to on-SoC processors, and finally, to the current bleeding edge of an _external coprocessor_, which is a physically separated and independent chip, dedicated to only security-sensitive operations [[1]](#references). The current ASHR implementation is based on coprocessors provided by the Google Titan chip [[2]](#references). The Titan chip has not been compromised, unlike most secure hardware platforms. Although high-reward bug bounties[[3]](#references) and the highest zero-day vulnerability payouts[[4]](#references) do not _guarantee_ security, they are a solid indication of the security level achieved.

### Rationale on using Mobile Hardware

Smartphones are among the most complex cases when it comes to information security. Their computing power has grown to the point of being almost indistinguishable from computers, they store the most valuable personal data and are used to carry out security-sensitive activities, which make them extremely attractive targets for attackers. With such a wide-ranging threat model and the fact that the vast computing base of a modern OS cannot be fully trusted, vendors have begun to use hardware to improve the security of their systems [[1]](#references).

### On TEEs and Hardware Security

Usually, Trusted Execution Environments (TEE) are created by integrating protection mechanisms directly into the processor or using dedicated external secure elements. However, both approaches only cover a narrow threat model, resulting in very limited security guarantees. For instance, enclaves nested in the application processor provide weak isolation and weak protection against side-channel attacks. Regardless of the approach used, TEEs often lack the ability to establish secure communication with peripherals, and most operating systems run inside TEEs do not provide state-of-the-art defense strategies, making them vulnerable to various attacks. Arguably, TEEs, such as Intel SGX [[5,6]](#references) or ARM TrustZone [[7]](#references), implemented on the main application processor, are insecure, _particularly_ when considering side-channel attacks. For that reason, ASHR is based on the bleeding edge of a dedicated coprocessor.

## Acurast Zero-Knowledge Runtime

The Acurast ZKP-based Runtime (AZKR) is another approach towards achieving general-purpose verifiable computation by leveraging recursive ZKP, which can generate and aggregate proofs for any computation. While the ASHR provides a performance advantage over the AZKR, the trust model of ZK-based protocols draws its core trust assumptions from the cryptographic scheme, not hardware-based security assumptions. The ASHR can scale horizontally across different applications; the AZKR requires specific circuits, assumptions, and requirements. On the other hand, ASHR provides an isolated environment for sensitive code, optimized for efficiency. Finally, trust-wise, ASHR rely on key attestation procedures and hardware-based trust assumptions, while AZKR systems mainly rely on semi-trusted sequencers and the reliance on cryptographic soundness.

#### References

[1] P. T. Maxime Rossi Bellom, Damiano Melotti, _2021: A Titan
M Odyssey_, 2021. Available on: https://i.blackhat.com/EU-21/Wednesday/EU-21-Rossi-Bellom-2021_A_Titan_M_Odyssey-wp.pdf  
[2] C. Wankhede, _What is the Titan M2 security chip in Google’s Pixel phones?_ https://www.androidauthority.com/titan-m2-google-3261547/, Jan 2023.  
[3] J. Reed, _Google’s bug bounty hits $12 million: What about the risks?_ https://securityintelligence.com/news/googles-bug-bounty-hits-12-million-what-about-the-risks-2/, May 2023.  
[4] ZERODIUM, _ZERODIUM Payouts for Mobiles_, https://zerodium.com/program.html  
[5] S. van Schaik, A. Kwong, and D. Genkin, _SGAxe: How SGX Fails in Practice_, 2020. Available on: https://api.semanticscholar.org/CorpusID:220248073  
[6] S. van Schaik, A. Seto, T. Yurek, A. Batori, B. AlBassam, C. Garman, D. Genkin, A. Miller, E. Ronen, and Y. Yarom, _SoK: SGX. Fail: How stuff get eXposed_, 2022.  
[7] S. Pinto and N. Santos, “Demystifying Arm TrustZone: A Comprehensive Survey,” ACM Computing Survey, Vol. 51, No. 6, Jan 2019. Available on
https://doi.org/10.1145/3291047

---

## Instances

Acurast will bootstrap three distinct networks: (a) the Acurast Testnet, (b) the Acurast Canary, and (c) the Acurast Mainnet.

### Acurast Devnet

The test network uses tokens with no governance and no staking utility. The service level provided is for test applications and experimental Proof-of-Concepts. The Acurast Testnet provides instant update cycles, whenever the code is ready, following the philosophy “Build, Break, and Fix Faster”. Testnet updates do not require governance, the Testnet is linked to the [Rococo](https://substrate.io/developers/rococo-network/) relay network.

- [Block Explorer ↗](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Facurast-devnet-ws.prod.gke.papers.tech#/explorer)
- [Acurast Hub ↗](https://hub.acurast.com)

### Acurast Canary

The canary network uses tokens with governance and staking utility. The service level provided is for production-grade applications. Acurast Canary provides shorter update cycles than the Mainnet, and also faster releases and deprecation of features. The canary network follows quarterly update cycles with a 9-month support span. Forkless network upgrades are activated and validated through the Canary network’s governance process, and it is linked to the [Kusama](https://kusama.network/) relay network.

1. **Pre-Net**
   Launched on programmer’s day September 13th, 2023. The Pre-Net launched without the governance process and has the Acurast Association’s collators producing blocks. Since there is no block reward, there will be no inflation in this phase. The purpose of this phase is to allow Developers and Processors to onboard and start exchanging their resources, all while providing a production-grade service level. During the pre-net phase, the governance and token transfers will remain disabled and no active transferring of tokens is expected at this stage.

   Therefore, developers who want to build zero-trust applications can request tokens through the social engagement faucet, more on this shortly.

1. **Alpha-Net**
   The purpose of this phase is to onboard external Collators and enable nominated Proof of Stake for the selection of those Collators.

   Comparable to Curve’s voted escrow model, the stake weight is based on the user’s selected lock time duration of the stake provided. The exact mechanics will be outlined in a future blog post.

   With the activation of the Alpha-Net, the block production will be rewarded, the rewards will be distributed from the Acurast protocol's adaptive inflation model. Sudo will remain active for this phase.

1. **Beta-Net**
   This phase removes sudo and migrates governance to the active stakers and enables token transfers.

   Acurast Canary will pave the road for the Acurast Mainnet launch going forward.

### Acurast Mainnet

The Acurast Mainnet uses tokens with governance and staking utility. The service level provided is for production-grade applications. The Mainnet follows yearly update cycles including features only after thorough battle testing on the Acurast Canary with a long-term support span of 5 years. The Mainnet also follows forkless upgrades activated through the Mainnet governance process and it is linked to the [Polkadot](https://www.polkadot.network/) relay network.

Anticipated launch later in 2025, connected to Polkadot.

---

## Acurast Collator Onboarding

This page describes the steps to take to onboard a collator on the Acurast Canary chain.

## Pre registration checks

- Make sure the node is setup with an identity as described in the [Node Setup ↗](/acurast-protocol/node-setup) guide.
- Make sure the node is fully synced.
- Make sure the node was started with the `--collator` flag.
- Make sure the node is running on hardware that meet the minimum requirements. It is possible to check by looking at the node logs when it first starts:

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/node-hardware-checks.png"),
    dark: useBaseUrl("/img/node-hardware-checks.png"),
  }}
/>

  If  the hardware is good enough, there should not be any warning log message after the benchmarks logs shown in the screenshot above.

## Set session key

A session key needs to be registered. To do that, first perform the `author_rotateKeys` RPC call in order to generate a new session key:

```bash
curl -H "Content-Type: application/json" \
--data '{
  "jsonrpc":"2.0",
  "method":"author_rotateKeys",
  "params":[],
  "id":1
}' \
http://localhost:9934
```

The output of the above command should be something like:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0xcc038816bd81c238bd1d163c48cea9c5e3b62899b8f193863f68268a719cca44"
}
```

> **_WARNING:_** If the node exposes the RPC port to the internet, directly or through a reverse proxy, please make sure to restart the node with the argument `--rpc-methods safe` so that RPC methods related to the collator keys cannot be called anymore. For more information, see the [RPC Deployment](https://paritytech.github.io/devops-guide/guides/rpc_index.html?#important-flags-for-running-an-rpc-node) page of the Parachain Devops guide.

Next, submit the extrinsic `session.setKeys` with the collator account to the Acurast Canary chain. The first parameter of the extrinsic call is the `result` hex string in the output of the previous RPC call.

Any tool can be used to submit the extrinsic call, the important thing is that it is submitted by the collator account.

One option is to use the [polkadotjs UI web app](https://dotapps-io.ipns.dweb.link/?rpc=wss%3A%2F%2Fpublic-rpc.canary.acurast.com#/extrinsics):

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/set-session-keys.png"),
    dark: useBaseUrl("/img/set-session-keys.png"),
  }}
/>

The screenshot above show how to call the `session.setKeys` extrinsic, where the first drop down menu selects the account submitting the extrinsic (in this example, the account comes from the PolkadotJS Chrome extension).

Then the `submit the following extrinsic` box, the `session` pallet and the `setKeys` extrinsic are selected. Finally, provide the arguments: first the key, which corresponds to the result of the previous RPC call, and a `0x00` for the proof argument.

## Register as candidate

Once the session key is registered, the collator can be registered as a candidate, this is done through the extrinsic `collatorSelection.registerAsCandidate`, as before, the important thing is that the extrinsic is submitted by the collator account:

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/register-as-candidate.png"),
    dark: useBaseUrl("/img/register-as-candidate.png"),
  }}
/>

If the extrinsic is submitted successfully, the collator node is now fully onboarded and should start authoring blocks within 6-12 hours.

---

## Node Setup

The recommended way to run the Acurast node is by using the published [Docker image](https://hub.docker.com/r/acurast/node-canary/tags).

## Get the chain spec

Download the Acurast chain spec from the Acurast GitHub repository: 

- [Acurast Canary chain spec](https://github.com/Acurast/acurast-substrate/blob/acurast-v0.21.0/chain-specs/acurast-kusama-parachain-2239-raw.json)
- [Acurast Mainnet Candidate chain spec](https://github.com/Acurast/acurast-substrate/blob/acurast-v0.21.0/chain-specs/acurast-mainnet-parachain-3396-raw.json)

## Configure the node

Create an `acurast-node` folder. Inside this folder, the following 2 folders and file:
- `chain-specs` - place the downloaded chain spec here
- `data` - this is where the node will store its data
- `docker-compose.yml` - this is where the docker-compose configuration will be placed

In the `docker-compose.yml` file, put the following content:

For Acurast Canary:

```yml
services:
  node:
    image: "acurast/node-canary:acurast-v0.20.0"
    command: "--chain /node/chain-specs/acurast-kusama-parachain-2239-raw.json \
      --base-path /node/data \
      --bootnodes /ip4/82.220.38.222/tcp/30334/ws/p2p/12D3KooWKrSDeVQ4tVQ1eGjqVAhAW3cgMQFHNCBbJrpmupEvdD4A \
      --port 30334 \
      --rpc-port 9934 \
      --rpc-external \
      --rpc-methods safe \
      --rpc-cors all \
      --name MyNode \ # choose an appropriate name here
      --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \
      --database=rocksdb \
      --pruning=archive"
    ports:
      - "30334:30334"
      - "9934:9934"
    volumes:
      - ./:/node
    logging:
      options:
        max-size: "10m"
        max-file: "3"
```

For Acurast Mainnet Candidate:

```yml
services:
  node:
    image: "acurast/node-mainnet:acurast-v0.20.0"
    command: "--chain /node/chain-specs/acurast-mainnet-parachain-3396-raw.json \
      --base-path /node/data \
      --bootnodes /ip4/82.220.38.222/tcp/30335/ws/p2p/12D3KooWMJM3htCon6tQ6FzRuWkxtwEkd3i5awZitdTviWwJX3KY \
      --port 30334 \
      --rpc-port 9934 \
      --rpc-external \
      --rpc-methods safe \
      --rpc-cors all \
      --name MyNode \ # choose an appropriate name here
      --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \
      --database=rocksdb \
      --pruning=archive"
    ports:
      - "30334:30334"
      - "9934:9934"
    volumes:
      - ./:/node
    logging:
      options:
        max-size: "10m"
        max-file: "3"
```

The configuration above will start the Acurast node with the following options:
- `--chain` - specifies the chain spec file
- `--base-path` - specifies the base path for the node data
- `--bootnodes` - specifies the bootnodes to connect to
- `--port` - specifies the p2p port for the node
- `--rpc-port` - specifies the RPC port for the node
- `--rpc-external` - allows external access to the RPC interface
- `--rpc-methods safe` - allows only safe RPC methods
- `--rpc-cors all` - allows all CORS requests
- `--name` - the name of the node
- `--telemetry-url` - The telemetry URL, the node will send telemetry data to [telemetry.polkadot.io](https://telemetry.polkadot.io/#/0xce7681fb12aa8f7265d229a9074be0ea1d5e99b53eedcec2deade43857901808) under the configured `name`
- `--database=rocksdb` - specifies the database type
- `--pruning=archive` - specifies the pruning mode, change `archive` to the number of blocks to keep if you want to prune the database

## Start the node

In `acurast-node` folder and run the following command:

```bash
docker compose up -d
```
This will start the Acurast node in detached mode. You can check the logs by running:

```bash
docker compose logs -f
```

## Run a Collator

A node can be turned into a collator configuring its identity. One way to do so is to use a tool like [subkey](https://docs.rs/crate/subkey/latest).

```bash
subkey generate
```

The output of the above command is something like:

```
Secret phrase:       <MNEMONIC>
  Network ID:        substrate
  Secret seed:       0x4f....
  Public key (hex):  0x86....
  Account ID:        0x86....
  Public key (SS58): 5F7Cm8Kt57dX3SkdtYYDGdMn3yiPvC8dr3oSratmGjjLmSss
  SS58 Address:      5F7Cm8Kt57dX3SkdtYYDGdMn3yiPvC8dr3oSratmGjjLmSss
```

Then configure the node with the generated key by calling the following RPC:

```bash
curl -H "Content-Type: application/json" \
--data '{
  "jsonrpc":"2.0",
  "method":"author_insertKey",
  "params":[
    "aura",
    "INSERT_SECRET_PHRASE",
    "INSERT_PUBLIC_KEY_HEX_FORMAT"
  ],
  "id":1
}' \
http://localhost:9934
```

In order for the above call to succeed, the node needs to be started with `--rpc-methods unsafe`. Once the key has been registered, the node can be restarted with the `--collator` flag.

The node is now setup as a collator, but it will not start authoring blocks yet. At this stage, the Acurast team manages the list of collators that can actually author blocks.

## Collator Onboarding

### Pre registration checks

- Make sure the node is setup with an identity as described above.
- Make sure the node is fully synced.
- Make sure the node was started with the `--collator` flag.
- Make sure the node is running on hardware that meet the minimum requirements. It is possible to check by looking at the node logs when it first starts:

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/node-hardware-checks.png"),
    dark: useBaseUrl("/img/node-hardware-checks.png"),
  }}
/>

  If  the hardware is good enough, there should not be any warning log message after the benchmarks logs shown in the screenshot above.

### Set session key

A session key needs to be registered. To do that, first perform the `author_rotateKeys` RPC call in order to generate a new session key:

```bash
curl -H "Content-Type: application/json" \
--data '{
  "jsonrpc":"2.0",
  "method":"author_rotateKeys",
  "params":[],
  "id":1
}' \
http://localhost:9934
```

The output of the above command should be something like:

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0xcc038816bd81c238bd1d163c48cea9c5e3b62899b8f193863f68268a719cca44"
}
```

> **_WARNING:_** If the node exposes the RPC port to the internet, directly or through a reverse proxy, please make sure to restart the node with the argument `--rpc-methods safe` so that RPC methods related to the collator keys cannot be called anymore. For more information, see the [RPC Deployment](https://paritytech.github.io/devops-guide/guides/rpc_index.html?#important-flags-for-running-an-rpc-node) page of the Parachain Devops guide.

Next, submit the extrinsic `session.setKeys` with the collator account to the Acurast Canary or Acurast Mainnet Candidate chain. The first parameter of the extrinsic call is the `result` hex string in the output of the previous RPC call.

Any tool can be used to submit the extrinsic call, the important thing is that it is submitted by the collator account.

One option is to use the polkadotjs UI web app:

- [Acurast Canary](https://dotapps-io.ipns.dweb.link/?rpc=wss%3A%2F%2Fpublic-rpc.canary.acurast.com#/extrinsics)
- [Acurast Mainnet Candidate](https://dotapps-io.ipns.dweb.link/?rpc=wss%3A%2F%2Fpublic-rpc.mainnet.acurast.com#/extrinsics)

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/set-session-keys.png"),
    dark: useBaseUrl("/img/set-session-keys.png"),
  }}
/>

The screenshot above show how to call the `session.setKeys` extrinsic, where the first drop down menu selects the account submitting the extrinsic (in this example, the account comes from the PolkadotJS Chrome extension).

Then the `submit the following extrinsic` box, the `session` pallet and the `setKeys` extrinsic are selected. Finally, provide the arguments: first the key, which corresponds to the result of the previous RPC call, and a `0x00` for the proof argument.

### Register as candidate

Once the session key is registered, the collator can be registered as a candidate, this is done through the extrinsic `collatorSelection.registerAsCandidate`, as before, the important thing is that the extrinsic is submitted by the collator account:

<ThemedImage
  width="1000px"
  sources={{
    light: useBaseUrl("/img/register-as-candidate.png"),
    dark: useBaseUrl("/img/register-as-candidate.png"),
  }}
/>

If the extrinsic is submitted successfully, the collator node is now fully onboarded and should start authoring blocks within 6-12 hours.

---

## Audits

# Security Audits

Security is a top priority for Acurast. Regular security audits are conducted security to ensure the safety and reliability the Acurast protocol, its components and infrastructure.

As the protocol and ecosystem continue to evolve, the Acurast Association is committed to conduct regular security audits across all components of the Acurast infrastructure.

The table below will be updated over time as new audits are completed, ensuring transparency and maintaining the highest security standards for users and developers.

The following table lists all finalized security audits conducted for Acurast components:

| Date       | Name                               | Auditor                                               | Component                                    | Link                                                                     |
| ---------- | ---------------------------------- | ----------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------------------ |
| 2025-10-23 | Acurast Chain Audit                | [Monethic](https://monethic.io/)                      | Acurast Substrate and Pallets Audit          | [View Report](/audits/20251023_Monoethic_Substrate.pdf)                  |
| 2025-10-23 | Acurast Token Smart Contract Audit | [inference](https://inference.ag/)                    | ACU ERC20 Token Contract for EVM Deployments | [View Report](/audits/20250210_InferenceAG_AcurastERC20Token.pdf)        |
| 2024-03-27 | Pentest tzBTC Android App          | [Compass Security](https://www.compass-security.com/) | Acurast Processor App (Android)              | [View Report](/audits/20240327_Compass_Security_Processor_App_xcBTC.pdf) |

---

## Create Address

This guide explains how to create an address with [Talisman](https://www.talisman.xyz/wallet) wallet. To install the browser extensions, follow their setup instructions or checkout [their walkshrough video](https://www.youtube.com/watch?v=spSPykclJ8I).

:::info

Most wallets allow to create a generic polkadot address that is supported by Acurast, this guide focuses on the Talisman wallet.

:::

Once you created your wallet follow this steps to create an Acurast address:

1. In any view of the Talisman browser extension, choose **`Add Account`** from the sidebar and then click **`New Account`**.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step1.png"),
    dark: useBaseUrl("/guide/create-address/step1.png"),
  }}
/>

2. Choose **`Polkadot`**.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step2.png"),
    dark: useBaseUrl("/guide/create-address/step2.png"),
  }}
/>

3. Enter your preferred name and click **`Create ->`**.

<ThemedImage
  width="70%"
  sources={{
    light: useBaseUrl("/guide/create-address/step3.png"),
    dark: useBaseUrl("/guide/create-address/step3.png"),
  }}
/>

4. The extensions will open up your newly created account and shows the name on the top-left. Open the dropdown menu next to Send/Receive and choose **`Copy address`**.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step4.png"),
    dark: useBaseUrl("/guide/create-address/step4.png"),
  }}
/>

5. Choose **`Substrate (Generic)`**, filter the list to find the item if necessary.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step5.png"),
    dark: useBaseUrl("/guide/create-address/step5.png"),
  }}
/>

6. In the popup, click **`Copy Address`**

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step6.png"),
    dark: useBaseUrl("/guide/create-address/step6.png"),
  }}
/>

Paste and store the address somewhere for later use.

7. Head over to [Acurast Faucet](https://faucet.acurast.com/) to get some funds.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/create-address/step7.png"),
    dark: useBaseUrl("/guide/create-address/step7.png"),
  }}
/>

---

## First App Deployment (Hub)

## Introduction

This tutorial will guide you through deploying a simple application on Acurast.

After deploying any app, you are eligible to get the reward for the "Deploy for the Rebellion" quest on the [Acurast Cloud Rebellion](https://rebellion.acurast.com/).

:::tip

For developers, reading the [First App Deployment](/developers/deploy-first-app) tutorial is recommended.

:::

### Writing the code

Code has been prepared that you can deploy. It is a simple webserver that will return a "Hello, World!" message.

The code is located here: ipfs://Qmb7sw1mH349wNJsoGWRs1HedAwVXtHPsW4YoXok15DeZL

## Deploying the Application

1. Open up the [Acurast Hub](https://hub.acurast.com/) and click on "Create Deployments".

2. You can leave the default settings and scroll down to "Deployment Code". There you click on "IPFS URL" and paste the link from above.

3. Now scroll down. You can optionally select on which processor your app will be deployed to, for example one of your own. But you can also leave it with the default option.

4. In the Execution Schedule settings, you select "One-time" and set the End time to a time in the future.

5. Scroll down and click on "Suggest Reward", then click on "Publish Deployment".

Success! You've successfully deployed your first application on Acurast!

## Verify the Deployment

Once the start time is reached, your app will be available at `https://<processor-address>.acu.run`. (Note: processor addresses are all lowercase.). You can find the address of the processor that runs your app in the deployment details in the Acurast Hub. Open the "Deployments" view, then click on the deployment and look at the "Assigned Processors" section. Copy the "Main Acurast Account", this is the processor address that runs your app.

---

## First App Deployment

## Introduction

This tutorial will guide you through deploying a simple application on Acurast. By the end of this guide, you'll have your first project ready and deployment up and running.

<iframe
  width="100%"
  style={{ "aspect-ratio": "368 / 239" }}
  src="https://www.youtube.com/embed/KSq-A-CJDyc"
  title="Create your first Acurast Deployment"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen"
  referrerpolicy="strict-origin-when-cross-origin"
  allowfullscreen
  webkitallowfullscreen
  mozallowfullscreen
></iframe>

:::tip

If you prefer to jump right in, you can take a look at one of the example projects:

- [Express Server on Acurast](https://github.com/Acurast/acurast-example-apps/tree/26ebfb27b1f0bdf4a146acafa792d47c155a34d5/apps/app-webserver)
- [Fetch data from an API](https://github.com/Acurast/acurast-example-apps/tree/26ebfb27b1f0bdf4a146acafa792d47c155a34d5/apps/app-fetch).

You can either clone those repositories, or set up a blank Acurast starter project by running `npx @acurast/cli new <project-name>`.

:::

## Prerequisites

- Basic knowledge of Node.js and the Command Line

## Setting up the Project

### Project Structure

The structure of a project looks exactly like a normal Node.js project:

```
├── dist
│   └── bundle.js
├── LICENSE
├── README.md
├── acurast.json
├── package-lock.json
├── package.json
├── src
│   └── index.ts
├── .env
├── tsconfig.json
└── webpack.config.js
```

There is only one file that is specific to Acurast: `acurast.json`. This file configures the deployment and is covered later in the tutorial.

### Writing the code

First, let's start by creating a simple node.js project. You can find the code of the example, including all the build steps and configurations, on [GitHub](https://github.com/Acurast/acurast-example-apps/blob/26ebfb27b1f0bdf4a146acafa792d47c155a34d5/apps/app-webserver/)

If you're interested only in the Acurast part of the tutorial, feel free to skip to the "Installing the Acurast CLI" step.

This app is a simple Express server that returns a "Hello, World!" message. This is the code of the app:

```typescript

/**
 * WARNING: This subdomain is NOT secure and should not be used in production.
 * Anyone can simply overwrite it with their own project and hijack requests
 * This is simply for testing purposes. If you need a secure way to host your
 * project, please reach out to us.
 */
const LOCALTUNNEL_SUBDOMAIN = ""; // This is the subdomain where your webserver will be available. Eg. https://example.acu.run
const LOCALTUNNEL_HOST = "https://proxy.acu.run/";
const LOCAL_PORT = 3000;

if (!LOCALTUNNEL_SUBDOMAIN) {
  console.log("LOCALTUNNEL_SUBDOMAIN must be set");
  process.exit(1);
}

const app = express();
app.use(express.json());

app.get("/", (req, res) => {
  res.send(`Hello from Acurast!`);
});

app.listen(LOCAL_PORT, () =>
  console.log(`Server listening on port ${LOCAL_PORT}!`)
);

const startTunnel = async () => {
  const tunnel = await localtunnel({
    subdomain: LOCALTUNNEL_SUBDOMAIN,
    host: LOCALTUNNEL_HOST,
    port: LOCAL_PORT,
  });

  console.log("Tunnel started at", tunnel.url);
};

startTunnel();
```

This code starts a webserver using express on port 3000, then starts a localtunnel tunnel to make the server publicly available.

Set the `LOCALTUNNEL_SUBDOMAIN` variable to specify where the server will be available. If set to `example`, the URL will be `https://example.acu.run`.

:::note

This localtunnel server is not secure and should not be used in production. Work is underway to make this secure by default, but if a secure way to host your project is needed now, please reach out via the community channels.

:::

### Building the project

To deploy a project to the Acurast Cloud, it needs to be bundled into a single js file. This example uses webpack. You can find the configuration in the example project on [GitHub](https://github.com/Acurast/acurast-example-apps/blob/26ebfb27b1f0bdf4a146acafa792d47c155a34d5/apps/app-webserver/)

Running `npm run bundle` will then output a single js file which includes all necessary dependencies.

The file is located in `dist/bundle.js`. It includes your code, as well as all the dependencies in a single file.

This is the file that will be deployed to the Acurast Cloud. You can run it locally with `node dist/bundle.js` to test it.

## Setting up the Acurast CLI

Now that the app is ready, the Acurast CLI needs to be set up. The CLI is a tool that allows you to deploy and manage your applications on the Acurast Cloud.

### Installation

Let's install the Acurast CLI globally using npm:

```bash
npm install -g @acurast/cli
```

To verify that the installation worked, you can run `acurast` in the terminal and it will show you the help page:

```text
tutorial % acurast
     _                            _      ____ _     ___
    / \   ___ _   _ _ __ __ _ ___| |_   / ___| |   |_ _|
   / _ \ / __| | | | '__/ _` / __| __| | |   | |    | |
  / ___ \ (__| |_| | | | (_| \__ \ |_  | |___| |___ | |
 /_/   \_\___|\__,_|_|  \__,_|___/\__|  \____|_____|___|

Usage: acurast [options] [command]

A cli to interact with the Acurast Network.

Options:
  -v, --version               output the version number
  -h, --help                  display help for command

Commands:
  deploy [options] [project]  Deploy the current project to the Acurast platform.
  init                        Create an acurast.json and .env file
  live [options] [project]    Run the code in a live code environment on a remote processor
  open                        Open Acurast websites in your browser
  help [command]              display help for command
```

### Adding Acurast Config to the Project

The next step is to add the Acurast Config to the project. To do that, run the following command:

```bash
acurast init
```

This will start an interactive guide, which will create `acurast.json` and `.env` files.

```text
tutorial % acurast init
Initializing Acurast CLI
There is no .env file, creating one now...
.env file created. Visit https://github.com/Acurast/acurast-cli to learn more.

The CLI will use the following address: 5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP

Visit the faucet to get some tokens: https://faucet.acurast.com?address=5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP

No package.json file found. This is unusual. Are you sure you are in the right directory?
? Enter the name of the project: tutorial
? Should the app be run one time or in an interval? One Time
? Enter the duration (eg. 1s, 5min or 2h): 1min
? What is the bundled javascript file to run? dist/bundle.js

🎉 Successfully created "acurast.json" and ".env" files

You can deploy your app using 'acurast deploy'
```

During the setup process, default values are set for most of the parameters, and they should work well for this example. You can always open the `acurast.json` file and change the configuration there. In the [CLI Docs](https://github.com/Acurast/acurast-cli?tab=readme-ov-file#configuration-details) you will find more information about the possible configurations.

These are the files that were generated:

acurast.json:

```json
{
  "projects": {
    "tutorial": {
      "projectName": "tutorial",
      "fileUrl": "dist/bundle.js",
      "network": "canary",
      "onlyAttestedDevices": true,
      "assignmentStrategy": {
        "type": "Single"
      },
      "execution": {
        "type": "onetime",
        "maxExecutionTimeInMs": 3600000
      },
      "maxAllowedStartDelayInMs": 10000,
      "usageLimit": {
        "maxMemory": 0,
        "maxNetworkRequests": 0,
        "maxStorage": 0
      },
      "numberOfReplicas": 1,
      "requiredModules": [],
      "minProcessorReputation": 0,
      "maxCostPerExecution": 1000000000,
      "includeEnvironmentVariables": [],
      "processorWhitelist": []
    }
  }
}
```

.env:

```text
ACURAST_MNEMONIC=bounce crack ostrich put entry comic wage all tilt nature rebel position
# ACURAST_IPFS_URL=
# ACURAST_IPFS_API_KEY=
```

### Getting ready for Deployment

To deploy the application, one more step is needed: getting some tokens from the faucet.

> [!TIP]
> You can import the mnemonic that was generated and stored in the .env file and import it in Talisman (Browser Extension) to access the same account in the [Web Console](https://hub.acurast.com/).

Let's get some tokens on your new account. You can run the `acurast deploy` command, which will check your balance, and displays the link to the Faucet page.

```text
tutorial % acurast deploy

Deploying project "tutorial"

Your balance is 0. Visit https://faucet.acurast.com?address=5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP to get some tokens.
```

Visit the link displayed in the CLI and follow the instructions to get some tokens. They should be available in a few seconds.

That's it! You're now ready to deploy your app.

## Deploying the Application

To deploy your application, run `acurast deploy`:

```text
tutorial % acurast deploy

Deploying project "tutorial"

The CLI will use the following address: 5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP

The deployment will be scheduled to start in 5 minutes 0 seconds.

There will be 1 executions with a cost of 0.001 cACU each.

❯ Deploying project (first execution scheduled in 246s)
  ✔ Submitted to Acurast (ipfs://Qmdk1zGq2h9SiMLUQN845rB9ii6YbpQXdFTHz3j8zXQp8C)
  ✔ Deployment registered (DeploymentID: 3,461)
  ⠇ Waiting for deployment to be matched with processors
  ◼ Waiting for processor acknowledgements
```

Congratulations, your deployment is now being registered in the network and executed soon! Check the CLI for more information about the deployment process.

## Verifying the Deployment

If you followed this tutorial, then your app will be available at `https://<your-subdomain>.acu.run`. ("\<your-subdomain\>" is the value you set for `LOCALTUNNEL_SUBDOMAIN` in the code).

Success! You've successfully deployed your first application on Acurast!

## Bonus: Working with Secret Environment Variables

You can use secret environment variables in Acurast depoyments. The environment variables that are encrypted during deployment and only decrypted when the code is run on the processor. This is useful for storing sensitive information like API keys.

To use environment variables in your project, you first need to add them to the `.env` file. For example, let's say you have an API key that you want to keep secret. You can add it to the `.env` file like this:

```text
# .env

API_KEY=your-api-key
```

To configure which of your deployments make use of the environment variables, edit the `acurast.json` file and add all the environment variables to include in the deployment to the `includeEnvironmentVariables` array.

```json
{
  "projects": {
    "tutorial": {
      "projectName": "tutorial",
      "fileUrl": "dist/bundle.js",
      "network": "canary",
      "onlyAttestedDevices": true,
      "assignmentStrategy": {
        "type": "Single"
      },
      "execution": {
        "type": "onetime",
        "maxExecutionTimeInMs": 60000
      },
      "maxAllowedStartDelayInMs": 10000,
      "usageLimit": {
        "maxMemory": 0,
        "maxNetworkRequests": 0,
        "maxStorage": 0
      },
      "numberOfReplicas": 1,
      "requiredModules": [],
      "minProcessorReputation": 0,
      "maxCostPerExecution": 1000000000,
      "includeEnvironmentVariables": ["API_KEY"],
      "processorWhitelist": []
    }
  }
}
```

Then, in your code, you can access the environment variables like this:

```typescript
const API_KEY = _STD_.env[API_KEY];
```

When you run `acurast deploy`, the environment variables will now automatically be added to your deployment.

If you run an interval based deployment with multiple executions, then you can even update the environment variables between executions. This is useful if you want to rotate your API keys regularly. To do that, simply update the `.env` file and run `acurast deployments <id> -e`. This will update the environment variables for the deployment with the given ID.

## Conclusion

Congratulations! You've successfully deployed your first application on Acurast! For more advanced features and detailed documentation, refer to [Acurast CLI Documentation](https://github.com/Acurast/acurast-cli/blob/main/README.md). Also make sure to join the Telegram or Discord to be part of the community!

## More Examples

For more inspiration, check out the [Acurast Examples](https://github.com/Acurast/acurast-example-apps) with examples showing various features:

- [app-env-vars](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-env-vars)
- [external-dependencies](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-external-dependencies)
- [fetch from API](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-fetch)
- [heic to png](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-heic-to-png)
- [puppeteer](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-puppeteer)
- [telegram-bot](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-telegram-bot)
- [wasm](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-wasm)
- [webserver](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-webserver)

---

## Deployment Runtime Environment

The deployment's script running on Processors has access to the following a set of APIs.

## **Top level functions**

```javascript
/**
 * Prints the given message to the console.
 * @param {string} message the message to print.
 */
function print(message);

/**
 * Performs an HTTP GET request.
 * @param {string} url the url to connect to.
 * @param {Record<string, string>} headers the request's headers, for example: { 'Accept': 'application/json' }.
 * @param {HttpSuccess} success the success callback function.
 * @param {HttpError} error the error callback function.
 */
function httpGET(url, headers, success, error);

/**
 * Performs an HTTP GET request.
 * @param {string} url the url to connect to.
 * @param {string} body a string representing the request's body.
 * @param {Record<string, string>} headers the request's headers, for example: { 'Content-Type': 'application/json' }.
 * @param {HttpSuccess} success the success callback function.
 * @param {HttpError} error the error callback function.
 */
function httpPOST(url, body, headers, success, error);

/**
 * @callback HttpSuccess
 * @param {string} payload the http request response payload as text.
 * @param {string} certificate a hex string representing the server certificate.
 */
type HttpSuccess = (payload, certificate) => void;

/**
 * @callback HttpError
 * @param {string} message an error message.
 */
type HttpError = (message) => void;

/**
 * Reads value from the environment.
 * @param {string} key The key used to get the value from the environment.
 * @return {string} The string value for the given key or undefined.
 */
function environment(key);
```

## **The \_STD\_ object**

At the top level, a `_STD_` object is defined. This object exposes additional functionalities.

### **Random**

```javascript
/**
 * Generates random bytes.
 * @return {string} Hex string representing random bytes.
 */
_STD_.random.generateSecureRandomHex();
```

### **Environment Variables**

```javascript
/**
 * Environment object populated with the environment variables defined during deployment creation.
 * For example, to access a variable defined with the "MY_KEY" key do: _STD_.env["MY_KEY"].
 */
_STD_.env;
```

### **App Info**

```javascript
/**
 * The processor app version as a string.
 *
 * Example: "1.9.2-canary"
 */
_STD_.app_info.version;
```

### **Deployment Info**

```javascript
/**
 * @return {DeploymentId} Object representing a deployment id.
 *
 * Example:
 * {
 *  origin: {
 *    kind: "Acurast",
 *    source: "2273f64ccf6e9dc13aedf111ca19da030909374f18c6a958b8e5c64927dc7b4f"
 *  },
 *  id: "3510"
 * }
 */
_STD_.job.getId();

type DeploymentId = { origin: { kind: string, source: string }, id: string };

/**
 * @return {number} The slot number of this deployment.
 */
_STD_.job.getSlot();

/**
 * @return {PublicKeys} Object containing the deployment specific public keys.
 *
 * Example:
 * {
 *  p256: "03aa8fa2bfe5a5d6789637c3b82b322b617f8c19e29a4b7d3eede17a2583312891",
 *  secp256k1: "02fcf1a928bab608989a0218831efd585d1e771669756e1033c60cff4bef6f28e5",
 *  ed25519: "7ce9f9b96a0f898ad109a594ab2c30a1682e7e6425910427c9390fdf16b11dd6"
 * }
 */
_STD_.job.getPublicKeys();

type PublicKeys = { p256: string, secp256k1: string, ed25519: string };
```

### **Device Info**

```javascript
/**
 * Get the main account public key.
 *
 * @since 1.9.2 (version code 58)
 *
 * @return {string} Hex string representing the main account public key.
 */
_STD_.device.getPublicKey();

/**
 * Get the main account address.
 *
 * @since 1.9.2 (version code 58)
 *
 * @return {string} String representing the main account address.
 */
_STD_.device.getAddress();
```

### **Signers**

```javascript
/**
 * Signs the given payload with the secp256r1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} payload Hex string representing the bytes to sign.
 * @return {string} Hex string representing the signature.
 */
_STD_.signers.secp256r1.sign(payload);

/**
 * Encrypts the given payload with the secp256r1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} publicKey Hex string representing the receiver's public key.
 * @param {string} salt Hex string representing the salt used for encryption.
 * @param {string} payload Hex string representing the bytes to encrypt.
 * @return {string} Hex string representing the encrypted payload.
 */
_STD_.signers.secp256r1.encrypt(publicKey, salt, payload);

/**
 * Decrypts the given payload with the secp256r1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} publicKey Hex string representing the sender's public key.
 * @param {string} salt Hex string representing the salt used for encryption.
 * @param {string} payload Hex string representing the bytes to decrypt.
 * @return {string} Hex string representing the decrypted payload.
 */
_STD_.signers.secp256r1.decrypt(publicKey, salt, payload);

/**
 * Signs the given payload with the secp256k1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} payload Hex string representing the bytes to sign.
 * @return {string} Hex string representing the signature.
 */
_STD_.signers.secp256k1.sign(payload);

/**
 * Encrypts the given payload with the secp256k1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} publicKey Hex string representing the receiver's public key.
 * @param {string} salt Hex string representing the salt used for encryption.
 * @param {string} payload Hex string representing the bytes to encrypt.
 * @return {string} Hex string representing the encrypted payload.
 */
_STD_.signers.secp256k1.encrypt(publicKey, salt, payload);

/**
 * Decrypts the given payload with the secp256k1 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 * 
 * @param {string} publicKey Hex string representing the sender's public key.
 * @param {string} salt Hex string representing the salt used for encryption.
 * @param {string} payload Hex string representing the bytes to decrypt.
 * @return {string} Hex string representing the decrypted payload.
 */
_STD_.signers.secp256k1.decrypt(publicKey, salt, payload);

/**
 * Signs the given payload with the ed25519 key generated for the current deployment.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} payload Hex string representing the bytes to sign.
 * @return {string} Hex string representing the signature.
 */
_STD_.signers.ed25519.sign(payload);
```

### **Websocket**

```javascript
/**
 * @param {string | string[]} url to the acurast websocket service.
 * @param {WsSuccess} success the success callback.
 * @param {WsError} error the error callback.
 */
_STD_.ws.open(url, success, error);

/**
 * @param {WsSuccess} success the success callback.
 * @param {WsError} error the error callback.
 */
_STD_.ws.close(success, error);

/**
 * @param {WsHandler} handler the handler called on every incoming message.
 */
_STD_.ws.registerPayloadHandler(handler);

/**
 * @param {string} recipient the public key in hex format of the recipient.
 * @param {string} payload the payload to send as a hex string.
 * @param {WsSuccess} success the success callback.
 * @param {WsError} error the error callback.
 */
_STD_.ws.send(recipient, payload, success, error);

/**
 * @callback WsSuccess
 */
type WsSuccess = () => void;

/**
 * @callback WsError
 * @param {string} message an error message.
 */
type WsError = (message) => void;

/**
 * @callback WsHandler
 * @param {WsPayload} payload the payload message.
 */
type WsHandler = (payload) => void;

type WsPayload = { sender: string, recipient: string, payload: string };
```

### **P2P**

```javascript
/**
 * @param {P2PConfig} config the node configuration.
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.start(config, success, error);

/**
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.close(success, error);

/**
 * @param {P2PMessageListener} listener the listener called on each incoming message.
 */
_STD_.p2p.onMessage(listener);

/**
 * @param {P2PPeer} receiver the peer who should receive the message.
 * @param {string} protocol the ID of the message protocol that should be used to transmit the message.
 * @param {string} bytes the payload to send as a hex string.
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.request(receiver, protocol, bytes, success, error);

/**
 * @param {P2PMessage} request the request to which this message responds.
 * @param {string} bytes the payload to send as a hex string.
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.respond(request, bytes, success, error);

/**
 * @param {string} peer the address or peer ID of the target peer to establish a connection with.
 * @param {P2PConnectOptions|undefined} options an optional configuration of this call.
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.connect(peer, options, success, error);

/**
 * @param {string} peer the address or peer ID of the target peer whose connection should be terminated.
 * @param {P2PSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.disconnect(peer, success, error);

/**
 * @param {string} peer the address or peer ID of the target peer to which the stream will be opened.
 * @param {string} protocol the protocol to be used for the stream.
 * @param {P2PStreamSuccess} success the success callback.
 * @param {P2PError} error the error callback.
 */
_STD_.p2p.openOutgoingStream(peer, protocol, success, error);

/**
 * @param {P2PStreamListener} listener the listener called on each incoming stream.
 */
_STD_.p2p.onIncomingStream(listener);

/**
 * @param {P2PConnectedRelayListener} listener the listener called whenever a relay is connected.
 */
_STD_.p2p.onRelayConnected(listener);

/**
 * @param {string} publicKey the public key from which the peer ID should be generated.
 * @return {string} the peer ID.
 */
_STD_.p2p.peerIdFromPublicKey(publicKey): string;

/**
 * @property {string[]} messageProtcols message protocols the node will support and use to send and receive messages.
 * @property {string[]} relays a list of public nodes that will serve as a proxy helping establish connections with nodes behind NATs and firewalls.
 * @property {number?} idleConnectionTimeout time in milliseconds after which idle connections will be closed, defaults to 15s if not provided.
 */
type P2PConfig = {
  messageProtocols: string[]
  relays: string[]
  idleConnectionTimeout?: number
};

/**
 * @callback P2PSuccess
 */
type P2PSuccess = () => void;

/**
 * @callback P2PStreamSuccess
 * @param {P2PStream} stream
 */
type P2PStreamSuccess = (stream) => void;

/**
 * @callback P2PError
 * @param {string} message an error message.
 */
type P2PError = (message) => void;

/**
 * @callback P2PMessageListener
 * @param {P2PMessage} message
 */
type P2PMessageListener = (payload) => void;

/**
 * @property {number|string|undefined} timeout an optional duration in milliseconds for which the client will attempt to establish a connection with the peer. If the connection is being established through a relay, the client will wait for a direct connection within the timeout period. If unsuccessful, it will fallback to the relayed connection, if available.
 */
type P2PConnectOptions = {
  timeout?: number | string
}

/**
 * @callback P2PStreamListener
 * @param {P2PStream} stream
 */
type P2PStreamListener = (stream) => void;

/**
 * @callback P2PConnectedRelayListener
 * @param {string} address the address of the connected relay.
 */
type P2PConnectedRelayListener = (address) => void;

/**
 * @property {P2PMessageType} type the type of the message.
 * @property {string} id internal id,
 * @property {P2Peer} sender the sender of the message.
 * @property {string} protocol the message protocol that was used to transmit this message.
 * @property {string} bytes the payload represented as a hex string.  
 */
type P2PMessage = { 
  type: P2PMessageType
  id: string
  sender: P2PPeer
  protocol: string
  bytes: string 
};

type P2PMessageType = 'request' | 'response';

type P2PPeer = { type: P2PPeerType, value: string };
type P2PPeerType = 'address' | 'peerId';

/**
 * @property {string} protocol
 * @property {P2PPeer} peer
 * @function read reads n bytes from the stream.
 * @function write writes bytes to the stream.
 * @function close closes the stream.
 */
type P2PStream = {
  protocol: string
  peer: P2PPeer
  read: P2PStreamRead
  write: P2PStreamWrite
  close: P2PStreamClose
};

/**
 * @function P2PStreamRead
 * @param {number} n the number of bytes to read from the stream.
 * @return {Promise<Buffer>} a promise that resolves with bytes read.
 */
type P2PStreamRead = (n) => Promise<Buffer>;

/**
 * @function P2PStreamWrite
 * @param {Uint8Array | string} bytes the data to be written to the stream, provided as a `Uint8Array` or hex string.
 */
type P2PStreamWrite = (bytes) => Promise<void>;

/**
 * @function P2PStreamClose
 */
type P2PStreamClose = () => Promise<void>;
```

### **Substrate functions**

```javascript
/**
 * Calls the `fulfill` extrinsic on the target substrate chain.
 * @param {string | string[]} nodes the node URL or array of node URLs.
 * @param {string} payload the string representation of the fulfill payload.
 * @param {object} extra an object with extra arguments. It needs to provide a `callIndex` which is the hex representation of the `fulfill` extrinsic's call index on the target substrate chain.
 * @param {SubstrateSuccess} success the success callback.
 * @param {SubstrateError} error the error callback.
 */
_STD_.chains.substrate.fulfill(nodes, payload, extra, success, error);

/**
 * @callback SubstrateSuccess
 * @param {string} operationHash the operation hash of the submitted extrinsic.
 */
type SubstrateSuccess = (operationHash) => void;

/**
 * @callback SubstrateError
 * @param {string[]} message an error message.
 */
type SubstrateError = (message) => void;
```

### **Substrate signer functions**

```javascript
/**
 * Sets the curve type to use when signing.
 * @param {'SECP256K1' | 'SECP256R1'} curveType
 */
_STD_.chains.substrate.signer.setSigner(curveType);

/**
 * Signs a payload.
 *
 * @since 1.9.2 (version code 58)
 *
 * @param {string} payload Hex string to sign.
 * @return {string} Hex string representing the signature.
 */
_STD_.chains.substrate.signer.sign(payload);
```

### **Substrate codec functions**

```javascript
/**
 * Hashes the given string using blake2b 256 bit.
 * @param {string} value
 * @return {string} The blake2b hash of the input value.
 */
_STD_.chains.substrate.codec.blakeTwo256(value);

/**
 * Encodes a number to the SCALE encoding.
 * @param {number | string} value the number to encode.
 * @param {8 | 32 | 64 | 128} bitSize the number's bit size.
 * @return {string} Hex string representing the SCALE encoded number.
 */
_STD_.chains.substrate.codec.encodeUnsignedNumber(value, bitSize);

/**
 * Encodes a number to the compact SCALE encoding.
 * @param {number | string} value the number to encode.
 * @return {string} Hex string representing the compact SCALE encoded number.
 */
_STD_.chains.substrate.codec.encodeCompactUnsignedNumber(value);

/**
 * Encodes bytes to SCALE encoding.
 * @param {string | ArrayBuffer} value hex string or an ArrayBuffer representing the bytes to encode.
 * @return {string} Hex string representing the SCALE encoded bytes.
 */
_STD_.chains.substrate.codec.encodeBytes(value);

/**
 * Encodes a boolean value to SCALE encoding.
 * @param {boolean} value the boolean value to encode.
 * @return {string} Hex string representing the SCALE encoded boolean.
 */
_STD_.chains.substrate.codec.encodeBoolean(value);

/**
 * Encodes a substrate address to SCALE encoding.
 * @param value the address to encode.
 * @return {string} Hex string representing the SCALE encoded address.
 */
_STD_.chains.substrate.codec.encodeAddress(value);

/**
 * Encodes a substrate address to a `MultiAddress` SCALE encoded vale.
 * @param value the address to encode.
 * @return {string} Hex string representing the SCALE encoded multi address.
 */
_STD_.chains.substrate.codec.encodeMultiAddress(value: string);
```

### **Substrate contract functions**

```javascript
/**
 * Calls the `fulfill` extrinsic on a contract deployed on a chain integrating the substrate contract pallet (`pallet-contract`).
 * @param {string | stirng[]} nodes the node URL or array of node URLs.
 * @param {string} callIndex an hex string representing the call index of the `call` extrinsic of `pallet-contract`.
 * @param {string} destination the contract address.
 * @param {string} data the contract call arguments as an hex string.
 * @param {object} extra objet containing additional arguments, it has to at least provide `refTime` and `proofSize` as string values. Additionally it can provide a `value` as a string representing the amount to transfer with the contract call, `method` as a string representing the method name to use instead of `fulfill` and `storageDepositLimit` as a string value. Example: `{ refTime: "3951114240", proofSize: "629760" }`.
 * @param {SubstrateSuccess} success the success callback.
 * @param {SubstrateError} error the error callback.
 */
_STD_.chains.substrate.contract.fulfill(
  nodes,
  callIndex,
  destination,
  data,
  extra,
  success,
  error
);

/**
 * Calls the `fulfill` extrinsic on a contract deployed on a chain integrating the substrate contract pallet (`pallet-contract`).
 * @param {string | stirng[]} nodes the node URL or array of node URLs.
 * @param {string} method a string representing the method name to call on the destination contract.
 * @param {string} destination the contract address.
 * @param {string} data the contract call arguments as an hex string.
 * @param {object} extra objet containing additional arguments. It can provide a `blockNumber` as a string to sepcify at what lever to read from and `storageDepositLimit` as a string value.
 * @param {SubstrateSuccess} success the success callback.
 * @param {SubstrateError} error the error callback.
 */
_STD_.chains.substrate.contract.callView(
  nodes,
  method,
  destination,
  data,
  extra,
  success,
  error
);
```

### **Substrate Gear functions**

```javascript
/**
 * Sends a message to an active Gear program extrinsic on a chain integrating the Gear protocol.
 * @param {string | stirng[]} nodes the node URL or array of node URLs.
 * @param {string} callIndex an hex string representing the call index of the `gear.sendMessage` extrinsic.
 * @param {string} destination the active program address.
 * @param {string} data an hex string encoding the method and arguments to call on the program.
 * @param {object} extra objet containing additional arguments, it has to provide `gasLimit` as a string, `value` as a string and `keepAlive` as a boolean. Example: `{ gasLimit: "2000000000", value: "0", keepAlive: true }`.
 * @param {SubstrateSuccess} success the success callback.
 * @param {SubstrateError} error the error callback.
 */
_STD_.chains.substrate.gear.sendMessage(
  nodes,
  callIndex,
  destination,
  data,
  extra,
  success,
  error
);
```

### **Tezos functions**

```javascript
/**
 * Calls the `fulfill` entrypoint on the Tezos Acurast Proxy contract.
 * @param {string | string[]} nodes the node URL or array of node URLs.
 * @param {any} payload the second argument for the `fulfill` entrypoint call on the Acurast Proxy contract. It represents a Michelson value that will be packed to bytes.
 * @param {object} extra object with extra arguments, it has to at least provide the values for the `fee`, `gasLimit` and `storageLimit` as numbers. Additionally it can provide an `entrypoint` as a string to use instead of `fulfill`. Example: `{ fee: 1500, gasLimit: 3000, storageLimit: 0 }`.
 * @param {TezosSuccess} success the success callback.
 * @param {TezosError} error the error callback.
 */
_STD_.chains.tezos.fulfill(nodes, payload, extra, success, error);

/**
 * Calls a custom entrypoint on a Tezos contract.
 * @param {string | string[]} nodes the node URL or array of node URLs.
 * @param {any} payload a Michelson value representing the arguments of the entrypoint being called.
 * @param {object} extra object with extra arguments, it has to at least provide the values for the `fee`, `gasLimit` and `storageLimit` as numbers. Additionally it can provide an `entrypoint` as a string to use instead of `fulfill` and `destination` as a string for the contract address to use instead of the default Acurast Proxy contract. Example: `{ fee: 1500, gasLimit: 3000, storageLimit: 0 }`.
 * @param {TezosSuccess} success the success callback.
 * @param {TezosError} error the error callback.
 */
_STD_.chains.tezos.customCall(nodes, payload, extra, success, error);

/**
 * @callback TezosSuccess
 * @param {string} operationHash the operation hash of the submitted operation.
 */
type TezosSuccess = (operationHash) => void;

/**
 * @callback TezosError
 * @param {string[]} message an error message.
 */
type TezosError = (message) => void;
```

### **Tezos encoding functions**

```javascript
/**
 * Packs the given micheline structure.
 * @param value an object representing a micheline structure.
 * @return {string} Hex string representing the packed value.
 */
_STD_.chains.tezos.encoding.pack(value);

/**
 * Encodes the given micheline structure into a hex value that can be used as key for big map values.
 * @param {object} value an object representing a micheline structure.
 * @return {string} Hex string representing the script hash encoded value.
 */
_STD_.chains.tezos.encoding.encodeExpr(value);
```

### **Tezos message signing**

```javascript
/**
 * Signs the given message and returns the signature.
 *
 * Before signing, the message is prepended with the utf8 bytes of the
 * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message),
 * then the resulting bytes are hashed with blake2b256.
 *
 * @param {string} message an hex string representing the bytes to sign
 * @return {string} Hex string representing the signature
 */
_STD_.chains.tezos.signer.sign(message);
```

### **Ethereum functions**

```javascript
/**
 * Calls `fulfill` on a ethereum contract.
 *
 * The `extra` argument is an object that can provide the following:
 * - `methodSignature`: an optional string representing the method signature, if not provided `fulfill(bytes)` is used.
 * - `gasLimit`: a string representing the transaction's gas limit, if not provided '9000000' is used.
 * - `maxPriorityFeePerGas`: a string representing the transaction's maxPriorityFeePerGas, if not provided '0' is used.
 * - `maxFeePerGas`: a string representing the transaction's maxFeePerGas, if not provided '0'.
 *
 * @param {string} url the node URL.
 * @param {string} destination the contract's address.
 * @param {string} payload a hex string representing the arguments for the method call.
 * @param {object} extra object with extra arguments.
 * @param {EthereumSuccess} success the success callback.
 * @param {EthereumError} error the success callback.
 */
_STD_.chains.ethereum.fulfill(url, destination, payload, extra, success, error);

/**
 * @callback EthereumSuccess
 * @param {string} operationHash the operation hash of the submitted operation.
 */
type EthereumSuccess = (operationHash) => void;

/**
 * @callback EthereumError
 * @param {string[]} message an error message.
 */
type EthereumError = (message) => void;

/**
 * @return {string} The processor's ethereum address for the current deployment.
 */
_STD_.chains.ethereum.getAddress();
```

### **Ethereum message signing**

```javascript
/**
 * Signs the given message and returns the signature.
 *
 * Before signing, the message is prepended with the utf8 bytes of the
 * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message),
 * then the resulting bytes are hashed with Keccak256.
 *
 * @param {string} message an hex string representing the bytes to sign
 * @return {string} Hex string representing the signature
 */
_STD_.chains.ethereum.signer.sign(message);
```

### **Ethereum ABI functions**

```javascript
/**
 * Encodes the given value.
 *
 * @param {any} value A string, number or an array/object containing strings and numbers.
 * @return {string} Hex string representing the encoded value.
 */
_STD_.chains.ethereum.abi.encode(value);

/**
 * Encodes a numeric value.
 *
 * @param {number|string} value A number or a hex string representing a big integer.
 * @param {number} bitLength A number specifying the bit length.
 * @param {boolean} isNatural A boolean indicating if it is a natural number.
 * @return {string} Hex string representing the encoded value.
 */
_STD_.chains.ethereum.abi.encodeNumeric(value, bitLength, isNatural);

/**
 * Encodes an objects as a structure.
 *
 * @param {any} value A string, number or an array/object containing strings and numbers.
 * @param {boolean} isDynamic A boolean indicating if it is a dynamic strucure.
 * @return {string} Hex string representing the encoded value.
 */
_STD_.chains.ethereum.abi.encodeStruct(value, isDynamic);
```

### **Bitcoin functions**

```javascript
/**
 * Returns the public key for the bitcoin chain.
 *
 * @since 1.5.0 (version code 28)
 *
 * @return {string} Hex string representing the public key
 */
_STD_.chains.bitcoin.getPublicKey();

/**
 * Returns an extended public key for the given derivation path.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} version an hex string representing the bytes that will be prepended to the extended public key bytes before the base58check encoding
 * @param {string} derivationPath the derivation path to use. Currently, the only valid value is "m/0/1".
 * @return {string} String representing the extended public key
 */
_STD_.chains.bitcoin.getExtendedPublicKey(version, derivationPath);
```

### **Bitcoin message signing**

```javascript
/**
 * Signs the given message and returns the signature.
 *
 * Before signing, the message is prepended with the utf8 bytes of the
 * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message).
 *
 * @since 1.4.0 (version code 26)
 *
 * @param {string} message an hex string representing the bytes to sign
 * @return {string} Hex string representing the signature
 */
_STD_.chains.bitcoin.signer.sign(message);

/**
 * Signs the given message and returns the signature.
 *
 * @since 1.4.0 (version code 26)
 *
 * @param {string} message an hex string representing the bytes to sign
 * @return {string} Hex string representing the signature
 */
_STD_.chains.bitcoin.signer.rawSign(message);

/**
 * Hashes the given value using SHA256.
 *
 * @since 1.4.0 (version code 26)
 *
 * @param {string} value an hex string representing the bytes to hash
 * @return {string} Hex string representing the sha256 hash
 */
_STD_.chains.bitcoin.signer.sha256(value);

/**
 * Signs the given message with a key derived with the given derivation path and returns the signature.
 *
 * Before signing, the message is prepended with the utf8 bytes of the
 * string 'acusig' and the script's ipfs hash ('acusig' + SCRIPT_HASH + message).
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} message an hex string representing the bytes to sign
 * @param {string} derivationPath the derivation path to use. Currently, the only valid value is "m/0/1"
 * @return {string} Hex string representing the signature
 */
_STD_.chains.bitcoin.signer.signHD(message, derivationPath);

/**
 * Signs the given message with a key derived with the given derivation path and returns the signature.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} message an hex string representing the bytes to sign
 * @param {string} derivationPath the derivation path to use. Currently, the only valid value is "m/0/1"
 * @return {string} Hex string representing the signature
 */
_STD_.chains.bitcoin.signer.rawSignHD(message, derivationPath);
```

### **Bitcoin utils functions**

```javascript
/**
 * Derives the given extended public key.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} xpub a string representing the extended public key to derive
 * @param {string} derivationPath the derivation path to use
 * @return {string} Hex string representing the derivced public key
 */
_STD_.chains.bitcoin.utils.derivePublicKey(xpub, derivationPath);

/**
 * Encodes the given bytes using base58check.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} value an hex string representing the bytes to encode
 * @return {string} The base58check encoded value
 */
_STD_.chains.bitcoin.utils.base58CheckEncode(value);

/**
 * Encodes the given bytes using base58.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} value an hex string representing the bytes to encode
 * @return {string} The base58 encoded value
 */
_STD_.chains.bitcoin.utils.base58Encode(value);

/**
 * Decodes the given base58check value.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} value a string representing the base58check value to decode
 * @return {string} Hex string representing the decoded value
 */
_STD_.chains.bitcoin.utils.base58CheckDecode(value);

/**
 * Decodes the given base58 value.
 *
 * @since 1.7.0 (version code 38)
 *
 * @param {string} value a string representing the base58 value to decode
 * @return {string} Hex string representing the decoded value
 */
_STD_.chains.bitcoin.utils.base58Decode(value);
```

### **Aeternity functions**

```javascript
/**
 * Calls `fulfill` on an aeternity contract.
 *
 * The `extra` argument is an object that can provide the following:
 * - `functionName`: an optional string representing the method name, if not provided `fulfill` is used.
 * - `gasLimit`: a string representing the transaction's gas limit, if not provided '25000' is used.
 * - `gasPrice`: a string representing the transaction's gas price, if not provided '1000000000' is used.
 *
 * @since 1.3.32
 *
 * @param {string} url the node URL.
 * @param {string} destination the contract's address.
 * @param {[object]} payload an array of encoded values. The objects inside this array need to be constructed using the functions found under `_STD_.chains.aeternity.data`.
 * @param {object} extra object with extra arguments.
 * @param {AeternitySuccess} success the success callback.
 * @param {AeternityError} error the success callback.
 */
_STD_.chains.aeternity.fulfill(
  url,
  destination,
  payload,
  extra,
  success,
  error
);

/**
 * Returns the Aeternity address.
 *
 * @since 1.3.34 (version code 19)
 *
 * @return {string} The Aeternity address
 */
_STD_.chains.aeternity.getAddress();

/**
 * @callback EthereumSuccess
 * @param {string} operationHash the operation hash of the submitted operation.
 */
type AeternitySuccess = (operationHash) => void;

/**
 * @callback EthereumError
 * @param {string[]} message an error message.
 */
type AeternityError = (message) => void;
```

### **Aeternity data encoding functions**

```javascript
/**
 * Returns an object representing an integer that can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {number | string} value a value representing an integer.
 * @return {object} an object representing an integer that can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.int(value);

/**
 * Returns an object representing a string that can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {string} value a string value.
 * @return {object} an object representing a string that can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.string(value);

/**
 * Returns an object representing bytes that can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {string} value an hex string representing the bytes.
 * @return {object} an object representing bytes that can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.bytes(value);

/**
 * Returns an object representing a list of objects that can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {object[]} values an array of objects that were created using the functions found under `_STD_.chains.aeternity.data`.
 * @return {object} an object representing a list of objects that can be used as payload in the `fulfill` call
 */
_STD_.chains.aeternity.data.list(values);

/**
 * Returns an object representing a tuple can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {object[]} values an array of objects that were created using the functions found under `_STD_.chains.aeternity.data`.
 * @return {object} an object representing a tuple can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.tuple(values);

/**
 * Returns an object representing a map can be used as payload in the `fulfill` call.
 *
 * The input value is an array of arrays of objects. The items need to be an array of size 2,
 * where the first element represents a map key and the second element represents its value:
 *
 * _STD_.chains.aeternity.data.map([
 *  [_STD_.chains.aeternity.data.string("key1"), _STD_.chains.aeternity.data.string("value1")],
 *  [_STD_.chains.aeternity.data.string("key2"), _STD_.chains.aeternity.data.string("value2")]
 * ]);
 *
 * @since 1.3.32
 *
 * @param {object[][]} values an array of arrays of objects that were created using the functions found under `_STD_.chains.aeternity.data`.
 * @return {object} an object representing a map can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.map(values);

/**
 * Returns an object representing an account pubkey can be used as payload in the `fulfill` call.
 *
 * @since 1.3.32
 *
 * @param {string} value a string representing an account pubkey .
 * @return {object} an object representing an account pubkey can be used as payload in the `fulfill` call.
 */
_STD_.chains.aeternity.data.account_pubkey(value);
```

---

## How to run an LLM on Acurast

## Introduction

This tutorial walks you through deploying and running an LLM on Acurast.

Acurast includes a module for running LLMs. Most models from [Hugging Face](https://huggingface.co/) in the `GGUF` format are supported.

:::tip

If you prefer to jump right in, you can take a look at the example project:

- [LLMs on Acurast](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-llm)

You can either clone the repository, or set up a blank Acurast starter project by running `npx @acurast/cli new <project-name>`.

:::

## Prerequisites

- Basic knowledge of Node.js and the Command Line

## Setting up the Project

### Project Structure

The structure of a project looks exactly like a normal Node.js project:

```
├── dist
│   └── bundle.js
├── LICENSE
├── README.md
├── acurast.json
├── package-lock.json
├── package.json
├── src
│   └── index.ts
├── .env
├── tsconfig.json
└── webpack.config.js
```

There is only one file that is specific to Acurast: `acurast.json`. This file configures the deployment and is covered later in the tutorial.

### Writing the code

First, let's start by creating a simple node.js project. You can find the code of the example, including all the build steps and configurations, on [GitHub](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-llm)

The app will host a local LLM server and make it available over HTTP.

```typescript

  MODEL_URL,
  MODEL_NAME,
  STORAGE_DIR,
  LOCALTUNNEL_HOST,
} from "./constants";

declare let _STD_: any;

const MODEL_FILE = path.resolve(STORAGE_DIR, MODEL_NAME);
async function downloadModel(url: string, dst: string) {
  console.log("Downloading model", MODEL_NAME);
  const res = await fetch(url);

  if (!res.body) {
    throw new Error("No response body");
  }

  console.log("Writing model to file:", dst);
  const writer = createWriteStream(dst);
  await finished(Readable.fromWeb(res.body as any).pipe(writer));
}
async function main() {
  if (!existsSync(MODEL_FILE)) {
    await downloadModel(MODEL_URL, MODEL_FILE);
  } else {
    console.log("Using already downloaded model:", MODEL_FILE);
  }
  console.log("model downloaded");

  _STD_.llama.server.start(
    ["--model", MODEL_FILE, "--ctx-size", "2048", "--threads", "8"],
    () => {
      // onCompletion
      console.log("Llama server closed.");
    },
    (error: any) => {
      // onError
      console.log("Llama server error:", error);
      throw error;
    }
  );
  const tunnel = await localtunnel({
    port: 8080,
    host: LOCALTUNNEL_HOST,
    subdomain: _STD_.device.getAddress().toLowerCase(),
  });

  console.log(tunnel.url);
}

main();
```

This code first downloads a model from Hugging Face, then starts the integrated LLM server and loads it. Finally, it uses localtunnel to make the server publicly available.

:::tip

The API is compatible with the [OpenAI-like API endpoints](https://lmstudio.ai/docs/basics/server#openai-like-api-endpoints)

:::

Set the `LOCALTUNNEL_SUBDOMAIN` variable to specify where the server will be available. If set to `llm`, the URL will be `https://llm.acu.run`.

:::note

This localtunnel server is not secure and should not be used in production. Work is underway to make this secure by default, but if a secure way to host your project is needed now, please reach out via the community channels.

:::

### Building the project

To deploy a project to the Acurast Cloud, it needs to be bundled into a single js file. This example uses webpack. You can find the configuration in the example project on [GitHub](https://github.com/Acurast/acurast-example-apps/blob/main/apps/app-llm/)

Running `npm run bundle` will then output a single js file which includes all necessary dependencies.

The file is located in `dist/bundle.js`. It includes your code, as well as all the dependencies in a single file.

This is the file that will be deployed to the Acurast Cloud.

## Setting up the Acurast CLI

Now that the app is ready, the Acurast CLI needs to be set up. The CLI is a tool that allows you to deploy and manage your applications on the Acurast Cloud.

### Installation

Let's install the Acurast CLI globally using npm:

```bash
npm install -g @acurast/cli
```

To verify that the installation worked, you can run `acurast` in the terminal and it will show you the help page:

```text
tutorial % acurast
     _                            _      ____ _     ___
    / \   ___ _   _ _ __ __ _ ___| |_   / ___| |   |_ _|
   / _ \ / __| | | | '__/ _` / __| __| | |   | |    | |
  / ___ \ (__| |_| | | | (_| \__ \ |_  | |___| |___ | |
 /_/   \_\___|\__,_|_|  \__,_|___/\__|  \____|_____|___|

Usage: acurast [options] [command]

A cli to interact with the Acurast Network.

Options:
  -v, --version               output the version number
  -h, --help                  display help for command

Commands:
  deploy [options] [project]  Deploy the current project to the Acurast platform.
  init                        Create an acurast.json and .env file
  live [options] [project]    Run the code in a live code environment on a remote processor
  open                        Open Acurast websites in your browser
  help [command]              display help for command
```

### Adding Acurast Config to the Project

The next step is to add the Acurast Config to the project. To do that, run the following command:

```bash
acurast init
```

This will start an interactive guide, which will create an `.env` file.

If you checked out the sample project, the `acurast.json` already exists, so this step will be skipped. You can open the `acurast.json` file and change the configuration there. In the [CLI Docs](https://github.com/Acurast/acurast-cli?tab=readme-ov-file#configuration-details) you will find more information about the possible configurations.

### Getting ready for Deployment

To deploy the application, one more step is needed: getting some tokens from the faucet.

> [!TIP]
> You can import the mnemonic that was generated and stored in the .env file and import it in Talisman (Browser Extension) to access the same account in the [Web Console](https://hub.acurast.com/).

Let's get some tokens on your new account. You can run the `acurast deploy` command, which will check your balance, and displays the link to the Faucet page.

```text
tutorial % acurast deploy --dry-run

Deploying project "app-llm"

Your balance is 0. Visit https://faucet.acurast.com?address=5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP to get some tokens.
```

Visit the link displayed in the CLI and follow the instructions to get some tokens. They should be available in a few seconds.

That's it! You're now ready to deploy your app.

## Deploying the Application

To deploy your application, run `acurast deploy`:

```text
tutorial % acurast deploy

Deploying project "tutorial"

The CLI will use the following address: 5GNimXAQhayQq8m8SxJt3xQmG2L3pGzeTkHopx9iPnrS6uHP

The deployment will be scheduled to start in 5 minutes 0 seconds.

There will be 1 executions with a cost of 0.001 cACU each.

❯ Deploying project (first execution scheduled in 246s)
  ✔ Submitted to Acurast (ipfs://...)
  ✔ Deployment registered (DeploymentID: ...)
  ⠇ Waiting for deployment to be matched with processors
  ◼ Waiting for processor acknowledgements
```

Congratulations, your deployment is now being registered in the network and executed soon! Check the CLI for more information about the deployment process.

## Verifying the Deployment

If you followed this tutorial, then your app will be available at `https://<your-subdomain>.acu.run`. ("\<your-subdomain\>" is the value you set for `LOCALTUNNEL_SUBDOMAIN` in the code).

Success! You've successfully deployed your first application on Acurast!

## Conclusion

Congratulations! You've successfully deployed your first application on Acurast! For more advanced features and detailed documentation, refer to [Acurast CLI Documentation](https://github.com/Acurast/acurast-cli/blob/main/README.md). Also make sure to join the Telegram or Discord to be part of the community!

## More Examples

For more inspiration, check out the [Acurast Examples](https://github.com/Acurast/acurast-example-apps) with examples showing various features:

- [app-env-vars](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-env-vars)
- [external-dependencies](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-external-dependencies)
- [fetch from API](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-fetch)
- [heic to png](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-heic-to-png)
- [puppeteer](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-puppeteer)
- [telegram-bot](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-telegram-bot)
- [wasm](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-wasm)
- [webserver](https://github.com/Acurast/acurast-example-apps/tree/main/apps/app-webserver)

---

## Deployments On Demand

On demand deployments are special kind of deployments that can be used to access a processor on demand from a dapp. This is achieved by having the deployment open a websocket connection to the acurast websocket service and setup handlers to process incoming messages.

### On Demand deployment script

The snippet below shows a very simple on demand deployment script that setups a websocket connection to the acurast websocket service and registers a payload handler that just sends back the message it receives.

```javascript
_STD_.ws.open(
  // open a websocket connection to the provided server
  ["wss://ws-1.ws-server-1.acurast.com", "wss://ws-1.ws-server-2.acurast.com "],
  () => {
    print("open: success");
    _STD_.ws.registerPayloadHandler((payload) => {
      // register a handler for incoming messages
      _STD_.ws.send(payload.sender, payload.payload); // just send back the received message
    });
  },
  (err) => {
    print("open: error " + err);
  }
);
```

An on demand deployment should be scheduled with a long duration since the deployment needs to continuously run in order to be able to process incoming messages.

### dApp integration

A dApp can start interacting with a running on demand deployment by integrating the [Acurast Typescript SDK](https://github.com/Acurast/acurast-typescript-sdk). See the example dapp for on how a simple integration works.

### Acurast websocket service

The Acurast websocket service is a P2P service that allows to simply send messages to clients connected to it. Clients are authenticated during the initial connection setup by signing a challenge with their private key (in case of a processor, that would be the private key specifically generated for the deployment creator).

The initial connection setup and authentication flow is as follows:

- Client sends an `init` message to the websocket service.
- Websocket service responds with a `challenge` message, providing the bytes to be signed.
- Client creates the payload to sign by concatenating the `challenge` bytes, the client public key and a 16 bytes nonce.
- Client signs the payload and responds to the challenge by sending beck the signature alongside the originally received challenge bytes, client public key and nonce.
- Websocket service verifies the signature and if it is valid accepts the connection.

After a client is authenticated, it can be addressed by specifying its public key as the recipient.

---

## FAQ


## Overall

### What is Acurast

Acurast is redefining compute by utilizing billions of smartphones – no data centers required. This verifiable, scalable, and confidential compute network enables users to run secure applications on decentralized infrastructure at scale—without compromising speed or privacy.

Acurast has already onboarded 141,428+ compute units worldwide on its incentivized testnet making it the most decentralized verifiable compute network available today. This impressive amount of compute already powers mission critical workloads with high-security and AI requirements.

This isn’t just another DePIN protocol — it’s a game-changer that’s redefining how the world computes.

### How can you provide compute with your phone on Acurast?

Get started as a [Processor](/acurast-processors) on Acurast and provide compute to receive rewards, either with Lite or Core:

#### **Acurast Processor Lite**

Lite is more flexible, can be installed on your everyday phone and activated to provide compute when it’s feasible for you. [How to onboard ↗](https://youtu.be/2Pxw2u0pZ_E?si=jHPCk82QI5I7rOKA)

Install the Acurast Processor Lite application on Android or iOS to get started.

[**Google Play ↗**](https://play.google.com/store/apps/details?id=com.acurast.attested.executor.sbs.canary)  
[**Apple App Store ↗**](https://apps.apple.com/kh/app/acurast-processor/id6517361921)

#### **Acurast Processor Core**

Core is meant for dedicated phones with the only purpose of providing compute to Acurast, completely locked down. [How to onboard ↗](https://www.youtube.com/watch?v=uLpBRUnmiPY)

**[Acurast Hub ↗](https://hub.acurast.com/)**

### Why is Acurast Using Mobile Phones?

When it comes to compute, phones are powerful and underestimated. These devices stand their ground in comparison with the server hardware of data centers. Still, they are more affordable in terms of acquisition cost and especially in terms of running cost due to their lower energy consumption. With your contribution, you can make them the perfect contender to disrupt the entire Compute industry.

### What are the use-case of Acurast?

Acurast enables decentralized, confidential, and scalable compute for various applications, including secure AI execution, decentralized bandwidth VPN services, automated on-chain trading strategies, and high-performance distributed computing for cost-efficient clusters, resilient website hosting, scalable zkProof generation and others.

### What wallets can I use on Acurast?

You can use any Polkadot-supported wallet. Wallets like MetaMask are also compatible.

**[See the full list of supported wallets ↗](/wallets/wallet-overview)**

### What is the difference between MIST, cACU & ACU?

- MIST are points, not tokens, used to incentivize rebels via the Cloud Rebellion.
- cACU is the Acurast Canary (incentivized testnet) token.
- ACU is the native token of the Acurast Mainnet.

### How can I fund my wallet?

You can use the [Acurast Faucet ↗](https://faucet.acurast.com/) to claim cACU tokens. On the Acurast Hub or in the Processor Lite app click on "Fund Account", this prefills your address. To request funds, select "Get tokens" and complete the captcha.

### Why is my balance decreasing sometimes?

Your balance may decrease slightly due to transaction fees when your Processor interacts with the Acurast network. Whenever the Processor reports to the chain (heartbeats, deployment acknowledgements, execution reports), minimal gas fees have to be paid, which can result in a decreasing balance. These fees are typically minimal, usually around 0.01 cACU per transaction.

### When is the TGE happening?

Originally planned for Q3 2025, the TGE was announced for November 17, 2025.

**[Read the full announcement ↗](https://acurast.com/blog/announcements/the-acurast-association-announces-launch-date-for-token-generation-event-tge-and-looks-ahead-to-next-steps/)**

### What is the cACU to ACU conversion mechanism?

#### How it works

1. User initiates conversion on Acurast Canary
2. cACU are burned on Canary
3. ACU is assigned to the account on Mainnet with a 1 to 1 ratio.
   e.g., 1000 cACU = 1000 ACU
4. On Mainnet the lock can be updated once between 3 to 48 cycles:  
   4.1. Default: Unlocked after 48x cycles at 28 days (3.7 years) = 1 to 1 ratio  
   4.2. Minimum: Unlocked after 3x cycles (2.8 months) = 6.5% ACU  
   4.3. Example: Unlocked after 24x cycles (1.75 years) = 50% ACU

#### Features

- The Conversion window is 90 days from its Activation afterwards no Conversion can be done.
- Converted and locked ACU can be Staked in Staked Compute Pool from Day 1 of Mainnet.
  ⟶ Staking Rewards are transferable (not locked) and claimable every epoch (1.5h)
- Converted and locked ACU can be used to participate in on-chain Governance
- If you continue to provide compute, you'll receive ACU rewards, that are transferable, from the Compute Pool.

### Is there an Airdrop?

The Acurast Association has announced the Cloud Rebellion Airdrop with 10,000,000 ACU tokens to be distributed based on MIST☁️ collected across all seasons (24 months linear vesting).

[More details ↗](https://acurast.com/blog/announcements/the-acurast-association-is-announcing-the-cloud-rebellion-airdrop-to-reward-its-rebels/)

## Acurast Processor

### What is the difference between Acurast Processor Core and Lite?

Acurast Processor Core is meant for dedicated phones, completely locked down, and intended only to provide compute to Acurast.

Whereas Lite is more flexible, can be installed on your everyday phone and activated to provide compute when it's feasible for you.

If you have a phone that you don't need any more for anything else, go with Core.

**[Learn more about Acurast Processors ↗](/acurast-processors)**

### What Android and iOS version are required?

The Android version required is Android 12 or higher, while the iPhone must be a 6s or later.

**[Check the list of recommended phones ↗](https://docs.google.com/spreadsheets/d/1ZvzmMVey4CM2tuif_zJfWiIxH1qkgA-l7BNJMw4vh54/edit?gid=1844886586#gid=1844886586)**

### Is there a difference in rewards between Acurast Processor Core and Lite?

As long as your phone is connected to the internet, and the Processor application app is running, you get a reward.

The difference comes into play for developer rewards. Developers can decide if they want to deploy on Core and Lite devices, or only on Core devices. Developers will want to utilize the first option for shorter deployments or by utilizing features of Lite e.g., a lot of different device locations and the second option for longer running deployments.

### I’m already running other Processors. Can I manage them all with one account?

Yes, most likely, you’ve connected a wallet to the Acurast Hub; follow these steps:

- Go to the Acurast Hub and select “Add New Device” to create a new QR code
- Install Acurast Processor Lite from Google Play or the Apple App Store on the phone
- Open Lite and select “Connect to Hub”
- Scan the QR code
- Complete the setup process, Lite is now connected to the Hub

### How can I tell how many heartbeats a processor has had?

The device heartbeats every 30 minutes. Scanning the blockchain allows you to look for all heartbeats, but that would take some time. To track the recent performance of your Processors, you can use the [Acurast Monitoring Bot](https://t.me/AcurastBot) on Telegram.

### Do I still get rewards if my Processor is missing heartbeats?

**[Benchmark rewards](/processors/rewards)** are distributed if one of 3 heartbeats of an epoch (roughly 90 minutes) was received on chain. This means your device can miss some heartbeats without missing out on rewards.

### Do I need to factory reset my phone?

You only need to factory reset your phone if you are onboarding a Core device. However, for Processor Lite, you can use your everyday device without factory resetting it.

Learn more about the differences between **[Core and Lite ↗](/acurast-processors)**

For step-by-step instructions on getting started, see the **[Compute Provider onboarding guide ↗](/processors/become-compute-provider)**.

## Lite

### How do I install Acurast Processor Lite?

Acurast Lite can be installed within minutes. The Acurast Processor Lite application can run on Android or iOS.

**[Follow the step-by-step installation guide ↗](/processors/become-compute-provider#for-processor-lite)**

### Android: Why do I need to setup an "Android Work" profile?

Android Work profiles are a built-in feature of Android, typically used by organizations to separate work apps and data from personal apps on the same device. This creates a secure, isolated container managed by an enterprise or organization.

The Acurast Processor Lite leverages this proven Android feature to create a secure, isolated environment for providing compute. The Work profile acts as a second profile completely independent from your private profile. By keeping your private profile separate from the one that provides compute, you'll get the best security and have no impact on your privacy.

### Android: Who manages the "Android work" profile?

You do. You're in complete control. Your device is connected to the decentralized Acurast protocol (Acurast Canary) and controlled by you. In no way do any individuals have access to your phone to install other applications in that work profile or make changes to it.

**Important Note:** During setup, you may see standard Android messages like "Your device isn't private" or "Your IT admin may see your data...". These are default warnings that appear whenever a work profile is created. In the case of Acurast, you remain in complete control - these are simply standard messages Android displays for all work profile setups.

### Android: How do I uninstall Acurast Processor Lite?

Because Lite uses the Android work profile, you’ll have to remove it completely to uninstall the app from your device.

If you have set up Lite with "Get Started" without a connection to your Acurast Hub, make sure that you backup your secret before removing the app; otherwise, you will lose access to your cACU.

Uninstalling Processor Lite:

1. Open the "Settings" with the cog on the top right on the Acurast Processor application (make sure you can see the compute status)
1. Click "Uninstall" and "Continue"
1. The Processor app in the work profile has been removed, you can now uninstall the lite app from your private profile and the work profile should be removed too (might be subject to Android version).

## Core

### How do I install Acurast Processor Core?

Acurast Processor Core is designed for dedicated Android phones. Follow the detailed installation instructions to get started.

**[Follow the step-by-step installation guide ↗](/processors/become-compute-provider#for-processor-core)**

### How to add Acurast Processor Core with NFC?

A short video by a community member onboard a device with a broken screen and an NFC.

**[NFC Onboarding ↗](https://youtu.be/lbAYV1kmV6o?si=_IbU5RfXYdlp5p-w)**

## Acurast Hub

### The "Add New Device" QR code is not showing?

When this happens, you can do two things:

- Disconnect and connect your wallet to the Hub.
- Use another browser.

---

## Post Mortem - 2025-11-04 - Acurast Canary chain stalled

## Post Mortem

### Date & Time

11.04.2025 at 2:30 GMT+2

### Engineer

Andreas Gassmann, Mike Godenzi

### Summary

The Acurast Canary chain stopped regularly producing new blocks for about 40mins, afterwards block production resumed but blocks were not finalized, after 2 hours blocks were finalized again.

### Status

Resolved

### Root causes

The Acurast collators could not produce any new blocks because the Kusama relay chain nodes they were connected to were in a crash loop, exhibiting the behavior described in [this Github issue](https://github.com/paritytech/polkadot-sdk/issues/4934).

The Kusama nodes were running on a version containing the bug detailed in the issue linked above. Restarting the nodes did not improve the situation.

After around 2 hours the Kusama relay nodes started to work properly again.

### Trigger

Kusama relay chain nodes used by the Acurast collators entered in a crash loop because of a bug described in [this Github issue](https://github.com/paritytech/polkadot-sdk/issues/4934).

### Resolution

The relay chain nodes affected started to work again after around 2 hours. Afterwards they have been all updated to the latest version.

In addition, all Acurast collators node have been configured with additional relay chain nodes as fallback.

### Timeline

2:30: 
- block production halts

2:42: 
- initial triage of issue
- discovered Kusama relay chain nodes used by the Acurast collators entered in a crash loop
- restarting of Kusama relay chain nodes
- restarting of all acurast parachain nodes
- blocks started to be produced but they were not getting finalized
- continues triage of issue after chain still did not recover

4:33:
- Kusama relay chain nodes started to work again

### Lesson learned

- Keep Kusama nodes up to date
- Have more additional backup nodes configured as the relay chain nodes for the Acurast Collators.

---

## Ecosystems & Integrations

# Supported Ecosystems & Integrations

Acurast is built with interoperability at its core and is able to support various Web3 ecosystems and has multiple ways of being integrated within various environments such as EVM, WASM, Substrate and others.

## Supported Ecosystems

Acurast supports ecosystems that have an active developer community and smart contract environments.

|                                                                                                           | Network                   | Environment      | [Level 1 Integration ↗](#level-1) | [Level 2 Integration ↗](#level-2) |
| --------------------------------------------------------------------------------------------------------- | ------------------------- | ---------------- | --------------------------------- | --------------------------------- |
| ![Aleph Zero](/img/A0-symbol_dark.svg "Aleph Zero") **Aleph Zero**                                        | In Development            | WASM             | ✅                                | ❌ \*                             |
| ![Arbitrum](/img/arbitrum_symbol.svg "Arbitrum") **Arbitrum**                                             | Mainnet, Goerli           | EVM              | ✅                                | ❌ \*                             |
| ![Astar](/img/astar_symbol.svg "Astar") **Astar**                                                         | Mainnet, Shibuya, zKatana | WASM, EVM, zKEVM | ✅                                | ❌ \*                             |
| ![Base](/img/base_symbol.svg "Base") **Base**                                                             | Mainnet, Goerli           | EVM              | ✅                                | ❌ \*                             |
| ![Binance Smart Chain](/img/binance-smart-chain_symbol.svg "Binance Smart Chain") **Binance Smart Chain** | Mainnet, Testnet          | EVM              | ✅                                | ❌ \*                             |
| ![BoB](/img/bob_symbol.svg "Binance Smart Chain") **BoB**                                                 | Testnet                   | EVM              | ✅                                | ❌ \*                             |
| ![Ethereumn](/img/ethereum_symbol.svg "Ethereum") **Ethereum**                                            | Mainnet                   | EVM              | ✅                                | ❌ \*                             |
| ![Monad](/img/monad_symbol.svg "Monad") **Monad**                                                         | Testnet                   | EVM              | ✅                                | ❌ \*                             |
| ![Moonbeam](/img/moonbeam_symbol.svg "Moonbeam") **Moonbeam**                                             | Mainnet, Moonbase         | EVM              | ✅                                | ❌ \*                             |
| ![Optimism](/img/optimism_symbol.svg "Optimism") **Optimism**                                             | Mainnet, Goerli           | EVM              | ✅                                | ❌ \*                             |
| ![Pendulum](/img/pendulum_symbol.svg "Pendulum") **Pendulum**                                             | Testnet                   | EVM              | ✅                                | ❌                                |
| ![Polygon](/img/polygon_symbol.svg "Polygon") **Polygon**                                                 | Mainnet, Mumbai           | EVM              | ✅                                | ❌ \*                             |
| ![Peaq](/img/peaq_symbol.svg "Peaq") **Peaq**                                                             | krest                     | EVM              | ✅                                | ❌ \*                             |
| ![Tezos](/img/tezos_symbol.svg "Tezos") **Tezos**                                                         | Mainnet, Ghostnet         | Tezos            | ✅                                | ✅                                |
| ![aeternity](/img/aeternity_symbol.svg "aeternity") **æternity**                                          | In Development            | æternity         | ✅                                | ❌ \*                             |

_\* In Development_

Support for additional ecosystems are added on a regular basis.

:::info

Are you considering an Acurast integration for your ecosystem and have questions?

Reach out to us on [hi@acurast.com](mailto:hi@acurast.com), on [Discord](https://discord.gg/wqgC6b6aKe) or [Telegram](https://t.me/acurastnetwork).

:::

## Integration Levels

### Level 1

With a _Level 1_ integration, the Acurast Protocol is capable to accept Deployments for the given destination ecosystem e.g., Ethereum smart contract. Developers are creating their Deployment requests through the Acurast Hub directly on the Acurast Protocol, funding the rewards with Acurast Tokens. Processors are capable of interacting with the destination directly, signing transactions and injecting them.

A simplified representation of the Level 1 flow:

<ThemedImage
  alt="Level 1 Flow"
  sources={{
    light: useBaseUrl("/img/acurast-level-1-flow_light.svg"),
    dark: useBaseUrl("/img/acurast-level-1-flow_dark.svg"),
  }}
/>

**Key takeaways:**

- Processors can interact with the destination and submit their output
- Developers create Acurast Deployments through the Acurast Hub directly on the Acurast Protocol which requires an Acurast Wallet and Acurast Tokens
- Developers need to fund transaction fees of the Processors with the asset of the destination ecosystem

### Level 2

A _Level 2_ integration provides a much improved developer experience and streamlined onboarding. An Acurast Proxy contract is deployed in the destination ecosystem that establishes a bi-directional cross-chain communication channel with Acurast Hyperdrive to the Acurast Protocol. Users e.g. on Ethereum can connect with their Ethereum wallet to the Acurast Hub and create a Deployment by interacting with the Proxy contract and rewarding Processors in the native currency. The created request is forwarded to the Acurast Protocol where that matches with eligible Processors that in turn then provide their output to the destination.

A simplified representation of the Level 2 flow:

<ThemedImage
  alt="Level 1 Flow"
  sources={{
    light: useBaseUrl("/img/acurast-level-2-flow_light.svg"),
    dark: useBaseUrl("/img/acurast-level-2-flow_dark.svg"),
  }}
/>

**Key takeaways:**

- Developers create Acurast Deployments through the Acurast Hub with a wallet from their ecosystem e.g., Metamask for Ethereum
- Rewards and transaction fees are provided in a native asset e.g., ETH
- Acurast Hyperdrive is used for cross-chain communication

## Integrations

Support for Acurast in a Web3 ecosystem can be achieved through various integration approaches:

- EVM
- Substrate
- Substrate with WASM
- Tezos

---

## Real Decentralized Compute Network

<ThemedImage
  width="240px"
  sources={{
    light: useBaseUrl("/img/acurast_logo_dark.svg"),
    dark: useBaseUrl("/img/acurast_logo_light.svg"),
  }}
/>

### Real Decentralized Compute Network - Powered by Phones

Acurast is redefining compute by utilizing billions of smartphones – no data centers required. This verifiable, scalable, and confidential compute network enables users to run secure applications on decentralized infrastructure at scale—without compromising speed or privacy.

Acurast has already onboarded 141,428+ compute units worldwide on its incentivized testnet making it the most decentralized verifiable compute network available today. This impressive amount of compute already powers mission critical workloads with high-security and AI requirements.

This isn’t just another DePIN protocol — it’s a game-changer that’s redefining how the world computes.

### Get Started

**[Deploy your first app ↗](/developers/deploy-first-app)**

**[Provide compute with your phone ↗](/acurast-processors/)**

  <ThemedImage
    sources={{
      light: useBaseUrl("/img/for-us-by-us.png"),
      dark: useBaseUrl("/img/for-us-by-us.png"),
    }}
  />

As global demand for computing power continues to skyrocket, control has gradually shifted into the hands of a few large, centralized providers. With AI’s rapid growth further accelerating the need for massive computing resources, the call for a truly decentralized, global-scale network—by the people, for the people—has never been stronger.

The only way to deliver on this vision is by rethinking decentralized compute from the ground up. Instead of relying on data centers or even servers, Acurast harnesses the world’s most abundant, powerful, and secure form of compute: smartphones.

### Decentralized by Design:

Over 141,428 phones as compute units stretch across the globe without relying on centralized data centers, united by a community of more than 75,000 "Cloud Rebels." Active in over 140 countries, this network sets a new standard for true decentralization.

### Scalable by Design:

By tapping into the compute of billions of smartphones worldwide, it’s primed to reach an unprecedented scale. Backed by academic research benchmarking its performance against leading centralized providers, it’s built for the future of decentralized compute. Battle-tested: The Acurast protocol has processed more than 250 million transactions on Testnet, demonstrating its impressive scalability and resilience.

### Secure by Design:

Acurast safeguards over $200 million in digital assets across leading networks—such as Bitcoin, Ethereum, Tezos, Polkadot, peaq and others. The smartphone's best-in-class Trusted Execution Environments (TEEs) confirm that hardware is genuine rather than fake, while maintaining confidentiality without requiring trust in the device owner. This strong emphasis on verifiability and confidentiality delivers the robust security essential for mass adoption of decentralized compute.

  <ThemedImage
    sources={{
      light: useBaseUrl("/img/highlights.png"),
      dark: useBaseUrl("/img/highlights.png"),
    }}
  />

  <ThemedImage
    sources={{
      light: useBaseUrl("/img/capabilites.png"),
      dark: useBaseUrl("/img/capabilites.png"),
    }}
  />

---

## Networks

A list of all related core infrastrucuture for each deployed Acurast network. More details on the functionalities of each network can be found in the [Protocol Architecture ↗](/acurast-protocol/architecture/instances)

## Acurast Canary

|          | Details                                                                                                       |
| -------- | ------------------------------------------------------------------------------------------------------------- |
| Token    | cACU                                                                                                          |
| RPC      | [RPC URL](wss://public-rpc.canary.acurast.com)                                                    |
| Explorer | [Block Explorer](https://polkadot.js.org/apps/?rpc=wss://public-rpc.canary.acurast.com#/explorer) |
| Faucet   | [faucet.acurast.com](https://faucet.acurast.com/)                                                             |

## Acurast Devnet

|          | Details                                                                                                |
| -------- | ------------------------------------------------------------------------------------------------------ |
| Token    | dACU                                                                                                   |
| RPC      | [RPC URL](wss://acurast-devnet-ws.prod.gke.papers.tech)                                                    |
| Explorer | [Block Explorer](https://polkadot.js.org/apps/?rpc=wss://acurast-devnet-ws.prod.gke.papers.tech#/explorer) |

---

## Processor Lite and Core

The Acurast processor is the app that is running on smartphones which take part in the Acurast Decentralized Compute Network. Acurast Processors are the infrastructure providers for Acurast's decentralized compute network. Processors provide the compute power of their phone and are used by developers to run their Deployments.

## Acurast Processor Core

_Only available for Android_

Provide compute with a dedicated phone, completely locked down and setup as a compute provider and join Acurast's decentralized compute network. Processor Core transforms your Android device into a dedicated compute node, offering maximum performance and reliability.

**Key Features:**

- **Dedicated Setup**: The device runs only the Acurast Processor app with everything else completely locked down
- **Maximum Performance**: Optimized for continuous operation and higher deployment execution rates
- **Enhanced Security**: Factory-reset device ensures a clean, secure environment
- **24/7 Operation**: Designed to run continuously, maximizing your reward potential
- **Priority Selection**: Developers often prefer Core devices for longer-running, critical deployments

**Requirements:**

- Android 12 or newer
- Device must not be rooted
- Locked bootloader required
- Factory reset necessary during setup

**[Setup Guide ↗](/processors/become-compute-provider#step-4-install-and-setup)**

## Acurast Processor Lite

Provide compute with your everyday phone and join Acurast's decentralized compute network. Processor Lite allows you to contribute compute power during edge-times (like while you sleep and charge) without dedicating an entire device.

**Key Features:**

- **Use Your Everyday Phone**: No need for a dedicated device - runs alongside your regular apps
- **Flexible Operation**: Provide compute during edge-times when your phone is idle (e.g., while charging overnight)
- **No Factory Reset**: Install and start providing compute immediately without wiping your device
- **Cross-Platform**: Available on both Android and iOS
- **Easy Setup**: Simple installation process with minimal configuration required
- **Android Work Profile**: Uses isolated work profile on Android for enhanced security and privacy

**Requirements:**

- **Android**: Android 12 or newer (non-rooted, locked bootloader)
- **iOS**: iPhone 6S or newer (iOS 15+)

**[Google Play ↗](https://play.google.com/store/apps/details?id=com.acurast.attested.executor.sbs.canary)**
**[Apple App Store ↗](https://apps.apple.com/us/app/acurast-processor/id6517361921)**
**[Setup Guide ↗](/processors/become-compute-provider#step-4-install-and-setup)**

## Security

For information about security audits, please visit **[Security Audit ↗](/audits)**.

---

## Become an Acurast Compute Provider

Join Acurast's decentralized compute network and start receiving rewards by providing compute power with your smartphone. This guide will walk you through everything you need to get started as a Compute Provider.

## What is a Compute Provider?

Compute Providers are people who run the Acurast Processor App to provide infrastructure for Acurast's decentralized compute network. As a Compute Provider, you provide the compute power of your phone to developers who run their applications (called Deployments) on the Acurast network. In return, you receive rewards in the form of tokens.

## What you need to become a Compute Provider

Getting started as a Compute Provider is simple. Here's what you need:

**One or more Compatible Smartphones**
- **Android**: Android 12 or newer (non-rooted, locked bootloader)
- **iOS**: iPhone 6S or newer (iOS 15+)
- Higher specs (CPU, RAM, Storage) will potentially result in higher rewards
- Check the [Recommended Phones list ↗](https://docs.google.com/spreadsheets/d/1ZvzmMVey4CM2tuif_zJfWiIxH1qkgA-l7BNJMw4vh54/edit#gid=1844886586) for optimal reward potential

**Internet Connection**
- Stable Wi-Fi or mobile data connection
- Reliable connectivity ensures consistent uptime and maximum rewards

**Power Source**
- Keep your device charged or connected to power
- Continuous operation maximizes your rewards

**Acurast Wallet**
- Created automatically when you install the Acurast Processor app
- Or import an existing wallet if you already have one

That's it! No technical expertise required - the Acurast Processor app handles everything else.

## Recommended Phones

Make sure to check out if your phone is on the list of recommended phones. In general, phones with higher specs will receive more rewards.

:::info

**[Recommended Phones ↗](https://docs.google.com/spreadsheets/d/1ZvzmMVey4CM2tuif_zJfWiIxH1qkgA-l7BNJMw4vh54/edit#gid=1844886586)**

:::

## Quick Start Guide

### Step 1: Check Device Compatibility

Before getting started, make sure your device meets the requirements:

**Android Requirements:**
- Android 12 or newer
- Device must not be rooted
- Bootloader must be locked

**iOS Requirements:**
- iPhone 6S or newer
- iOS 15 or newer

### Step 2: Get an Acurast Compatible Wallet

Before setting up your Processor, you'll need a wallet to receive your rewards.

**Recommended Wallets:**
- **[MetaMask ↗](https://metamask.io/)** - Popular multi-chain wallet
- **[Talisman ↗](https://talisman.xyz/)** - Full-featured Substrate wallet
- **[SubWallet ↗](https://www.subwallet.app/)** - Multi-chain Substrate wallet

For more supported wallets and detailed wallet setup guides, see the [Wallet Documentation](/wallets/wallet-overview).

**Quick Setup (Talisman):**

1. Install the [Talisman browser extension ↗](https://talisman.xyz/)
2. Click "New Wallet" and create a strong password
3. Write down your recovery phrase and store it safely (never share this!)
4. Add Acurast network: Click the network dropdown → Search for "Acurast" → Enable it

### Step 3: Choose Your Processor Type

Acurast offers two types of Processors:

  
    <iframe
      style={{position: 'absolute', top: 0, left: 0, width: '100%', height: '100%'}}
      src="https://www.youtube.com/embed/aVKVflF-rLU"
      title="Acurast Processor Types"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen>
    </iframe>
  

**Acurast Processor Core** (Android only)
- Dedicated device setup for maximum performance
- Requires factory reset of your Android phone
- Only the Acurast Processor app will run on this phone (everything else is completely locked down)
- Best for serious compute providers
- [Setup via Acurast Hub ↗](https://hub.acurast.com/)

**Acurast Processor Lite** (Android & iOS)
- Runs on your everyday phone in edge-times (e.g. while you sleep and charge)
- No factory reset required
- Easy to get started
- [Download for Android ↗](https://play.google.com/store/apps/details?id=com.acurast.attested.executor.sbs.canary)
- [Download for iOS ↗](https://apps.apple.com/us/app/acurast-processor/id6517361921)

### Step 4: Install and Setup

#### For Processor Core

1. Factory reset your Android phone
2. Visit [Acurast Hub ↗](https://hub.acurast.com/) and connect with your wallet
3. Follow the detailed setup instructions for dedicated processors
4. Lock down the device as a dedicated compute provider

  
    <iframe
      style={{position: 'absolute', top: 0, left: 0, width: '100%', height: '100%'}}
      src="https://www.youtube.com/embed/uLpBRUnmiPY"
      title="Acurast Processor Core Setup"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen>
    </iframe>
  

#### For Processor Lite

1. Download the app from [Google Play ↗](https://play.google.com/store/apps/details?id=com.acurast.attested.executor.sbs.canary) or [Apple App Store ↗](https://apps.apple.com/us/app/acurast-processor/id6517361921)
2. Open the app and give the required permissions
3. Visit [Acurast Hub ↗](https://hub.acurast.com/), connect your wallet and use 'Onboard with hub'. Alternatively tap "Get Started" and a wallet will be created for you on the app.
4. Complete the initial setup wizard
5. Keep your device connected to the internet

  
    <iframe
      style={{position: 'absolute', top: 0, left: 0, width: '100%', height: '100%'}}
      src="https://www.youtube.com/embed/2Pxw2u0pZ_E"
      title="Acurast Processor Lite Setup"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen>
    </iframe>
  

### Step 5: Start Receiving Rewards

Once your Processor is set up and running, you'll automatically start receiving rewards:

**Deployment Execution Rewards**
- Receive tokens (cACU on Canary, ACU on Mainnet) when developers use your compute power
- Rewards are distributed when your Processor successfully executes code deployments
- The more deployments your Processors execute, the more you receive
- Developers set the amount they are willing to give as reward

**Benchmark Rewards**
- Receive based on your device's [benchmark performance](/acurast-processors/benchmarks)
- 12,500 cACU distributed per epoch (~1.5 hours) on Canary
- Rewards split across 4 benchmark pools (CPU, memory, network, storage)
- Higher-spec devices typically receive more

**Cloud Rebellion Points**
- Join the [Cloud Rebellion ↗](https://rebellion.acurast.com/) to receive MIST points
- Complete quests and onboard more Compute Providers
- Invite others to join and receive additional rewards

## Best Practices

To maximize your rewards and ensure smooth operation:

- **Keep your device connected to the internet** - Your Processor needs stable internet to receive and execute deployments

- **Ensure adequate power** - Keep your device charged or connected to power

- **Use recommended devices** - Higher-spec phones from the recommended list will receive more benchmark rewards

- **Run multiple processors** - Scale your compute provision by running [multiple devices](/acurast-processors/multiple-processors)

- **Monitor performance** - Check your benchmark scores and uptime regularly

## Next Steps

Now that you're set up as a compute provider, explore these resources:

- Learn about [Processor Lite and Core](/acurast-processors) in detail
- Understand how [Benchmarks](/acurast-processors/benchmarks) affect your rewards
- Scale up by running [Multiple Processors](/acurast-processors/multiple-processors)
- Join the [Cloud Rebellion ↗](https://rebellion.acurast.com/)
- Follow us on [X ↗](https://x.com/Acurast)
- Join the community on [Discord](https://discord.gg/wqgC6b6aKe) or [Telegram](https://t.me/acurastnetwork)

## Need Help?

If you encounter any issues during setup or have questions:

- Check the [FAQ](/faq) for common questions
- Join the [Discord community ↗](https://discord.gg/wqgC6b6aKe)
- Reach out on [Telegram ↗](https://t.me/acurastnetwork)
- Contact support through the [Acurast Hub ↗](https://hub.acurast.com/)

Welcome to the Acurast network!

---

## Benchmarks

Benchmark tests on Acurast phones are vital to determine the compute power of the participating devices. The compute metrics determined by these benchmark tests are relevant for **matching phones** to the right tasks based on their capabilities, **calculating benchmark rewards** distributed for the provision of phones, and **determining [staked compute rewards](/staked-compute)**. Better hardware usually leads to a higher benchmark score.

## Overview

The [Acurast Benchmark](https://github.com/Acurast/acurast-benchmark) suite is designed to evaluate the performance of Processors running in the Acurast network. It provides a comprehensive set of tests to measure computational throughput, memory allocation and access efficiency, and storage read/write performance. The benchmarks include support for multithreaded execution to leverage modern multi-core architectures.

The benchmark suite evaluates three main components: **CPU**, **RAM**, and **Storage**. Each component contributes to the overall performance score of the device.

## CPU Benchmarks

The CPU benchmarks evaluate the computational capabilities of the device through three test categories:

### Test Categories

- **Crypto**: Measures encryption and decryption throughput using [AES-256](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) and hashing throughput using [SHA-256](https://en.wikipedia.org/wiki/Secure_Hash_Algorithms).
- **Math**: Tests matrix multiplication performance, with support for three algorithms:
  - [**Divide and Conquer**](https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Divide-and-conquer_algorithm): A recursive algorithm used for single-threaded execution when SIMD is disabled or for multithreaded benchmarks in general.
  - [**Iterative**](https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Iterative_algorithm): A straightforward implementation used when SIMD optimization is enabled but the device lacks the required hardware capabilities.
  - **SIMD-Optimized**: An optimized version of the iterative algorithm leveraging SIMD instructions, used when the device supports the required hardware capabilities.
- **Sort**: Benchmarks sorting algorithms, including single-threaded and multithreaded [merge sort](https://en.wikipedia.org/wiki/Merge_sort).

### Execution Modes

The CPU benchmark suite is available in two variations:

- **Single-Core**: Executes all tests using a single thread to evaluate the performance of a single core.
- **Multi-Core**: Executes all tests using multiple threads to leverage the full computational power of the device.

### Configuration

- **Crypto**: Configure the duration of the test and the size of the data to encrypt and hash.
- **Math**: Specify the matrix size, whether to enable SIMD optimizations, and the duration of the test.
- **Sort**: Define the size of the dataset and the duration of the test.

### Score Calculation

The CPU score is calculated as the average of the throughput ($TPS$) values from the Crypto, Math, and Sort benchmarks. Higher throughput results in a higher score.

$$
score_{CPU} = \frac{TPS_{crypto} + TPS_{math} + TPS_{sort}}{3}
$$

## RAM Benchmarks

The RAM benchmarks assess memory allocation and access patterns through two test categories:

### Test Categories

- **Allocation**: Measures the time taken to allocate and initialize memory.
- **Access**: Evaluates sequential, random, and concurrent memory access patterns.

### Configuration

- **Allocation**: Specify the number of iterations and the size of memory to allocate in each iteration.
- **Access**: Configure the number of iterations and the size of data for sequential, random, and concurrent access patterns.

### Score Calculation

The RAM score is calculated based on the inverse of the average times ($T$) for Allocation and Access benchmarks. Higher efficiency results in a higher score. The total available RAM memory is also recorded.

$$
score_{RAM} = \frac{T_{alloc}^{-1} + T_{access\_seq}^{-1} + T_{access\_rand}^{-1} + T_{access\_concurr}^{-1}}{4}
$$

## Storage Benchmarks

The storage benchmarks focus on file I/O performance through read and write operations.

### Test Categories

- **Access**: Measures sequential and random read/write throughput for files on the storage medium.

### Configuration

- **Access**: Define the number of iterations and the size of data for sequential and random read/write operations.

### Score Calculation

The Storage score is calculated as the average of the inversed average times ($T$) for sequential and random read/write operations. Lower average times result in a higher score. The available storage capacity is also recorded.

$$
score_{storage} = \frac{T_{access\_seq}^{-1} + T_{access\_rand}^{-1}}{2}
$$

## Overall Scoring

The compute overall score is calculated as a weighted average that combines performance metrics from CPU, RAM, and Storage benchmarks to provide a comprehensive evaluation of a device's computational capabilities.

$$
score_{all} = w(score_{CPU\ SC}) + w(score_{CPU\ MC}) + w(mem_{RAM}) + w(score_{RAM}) + w(mem_{storage}) + w(score_{storage})
$$

Where:

$$
w(m) = \frac{m}{N_{m}} \times W_{m}
$$

And:

- $W_{m}$: Weight assigned to each metric pool ($0 \leqslant W_{m} \leqslant 1$ and $\sum_{m} W_{m} = 1$)
- $N_{m}$: Normalization factor representing the sum of all scores submitted to the metric pool. Uses the previous epoch's total if available, otherwise the current epoch's total, or defaults to $m$ if no data exists on the chain.
- $score_{CPU\ SC}$: CPU performance score (Single-Core)
- $score_{CPU\ MC}$: CPU performance score (Multi-Core)
- $mem_{RAM}$: Total available RAM memory
- $score_{RAM}$: RAM performance score
- $mem_{storage}$: Available storage capacity
- $score_{storage}$: Storage performance score

To make the final score human-readable, a scaling factor of $10^9$ is applied.

$$
score_{display} = score_{all} \times 10^9
$$

### Component Weights

The components are weighted as follows:

- CPU Single-Core: $W_{CPU\ SC} = 0.2307$
- CPU Multi-Core: $W_{CPU\ MC} = 0.2307$
- RAM Total: $W_{RAM\ mem} = 0.4615$
- RAM Speed: $W_{RAM\ score} = 0$
- Storage Total: $W_{storage\ mem} = 0.0769$
- Storage Speed: $W_{storage\ score} = 0$

If all weights equal $0$, the components are weighted equally:

$$
W_{m} = \frac{1}{n} \text{ if active, or } W_{m} = 0 \text{ otherwise}
$$

Where:

- $n$: The number of active metric pools

---

## Run Multiple Processors (Farms)

### Running multiple Acurast Processors

Running multiple Acurast Processors presents additional challenges. For optimal performance and availability, it is recommended to set up each Processor with Acurast Core on a freshly wiped device. Below are recommendations and best practices for managing multiple Acurast devices.

### Use a separate wallet

Each Acurast Processor is managed by a designated manager address. If you plan to run multiple Acurast Processors, ensure they are all managed by the same account. This manager account will be responsible for overseeing all devices and will collect the associated computation rewards.

Good experiences have been made with the following wallets:

- Metamask
- Talisman
- Solana wallets
- SubWallet
- Other EVM wallets via Walletconnect

Set up an Acurast account, back up the seed phrase according to standard best practices, and connect the account to the Acurast Hub. Then, obtain some initial funds from the faucet - these are required to register your first devices on the Acurast chain.

### Onboarding multiple phones at once

To onboard multiple phones simultaneously, users can opt to receive a QR code designed for bulk onboarding. This QR code can also include Wi-Fi access point information, eliminating the need to manually enter it on each device.

1. Connect your wallet to the [Acurast Hub](https://hub.acurast.com)
2. Click _Add Phone_ and sign from your wallet
3. Above the QR code change to _Multi Use_ and sign again
4. A QR code for multiple onboardings will be displayed
5. Toggle the _Advanced_ functions
6. Set the WiFi SSID to your Access Point, enter the WiFi Password for that AP and set the right WiFi Type, click _Save Changes_
7. Ensure phones are wiped, tap 6x on the first screen after starting the phone and scan the displayed QR code to set up the phones
8. Follow the instructions on screen

### Manage the phones in the Hub

The Acurast Hub is the place to manage your Acurast Processors. Users find it on [hub.acurast.com](https://hub.acurast.com)

#### Phones list page

On the _Phones_ page users see a list of phones they have deployed the Acurast Processor to. This page helps you to manage your devices.

<ThemedImage
  alt="Hub Phones List"
  sources={{
    light: useBaseUrl("/img/hub_phone_list.png"),
    dark: useBaseUrl("/img/hub_phone_list.png"),
  }}
/>

- _Acurast address_: Device address with _identicon_ (click on the identicon to copy the device's address)
- _Last seen_: When the last heartbeat was detected
- _Attested_: If the device got attestation
- _Battery_: Battery health information (needs to be activated, see below)
- _Star rating_: Devices reputation, based on successfully completed jobs (default is 0.5)
- _Processor version_: OS and Processor version
- _Status_: Number of currently running Deployments

- _Settings_ (Cog wheel:) Opens the device settings
- _Bin_: Remove the device from your list and deregister it from Acurast

- _Advanced_: Toggle advanced settings

  - _Activate management endpoint_ (needed to activate battery monitoring)
  - _Enter_ a custom management endpoint (eg. for a self hosted management backend)

  - _Processor Ownership:_ Transfer all Processors to a different manager

- _Update Processors_: Sends a signal to trigger the update of the Processor apps (the update can take a few minutes to be reflected)

### Monitoring Processors

#### Telegram Bot

To track the recent performance of the Processors and additional information, users can use the Acurast Monitoring Bot on Telegram: [@AcurastBot](https://t.me/AcurastBot)

#### Battery monitoring

The Acurast Hub offers some battery health and status indicators for every phone. This feature needs to be activated.

1. Connect your wallet to the [Acurast Hub](https://hub.acurast.com)
2. Go to _Phones_
3. Toggle the _Advanced_ functions
4. Toggle management endpoint by setting it to _active_
5. Wait until the devices show a battery indicator (this can take up to 2 heartbeats and a reload of the page)

#### Advanced battery monitoring with self hosted management backend

This tool is intended for advanced users who can host their own software and need to monitor a large number of phones. It also enables integration with external systems — for example, to control smart plugs or trigger third party systems. An early version of the tool is available here: [Acurast Processor Management Backend](https://github.com/Acurast/acurast-Processor-management-backend).

### Practical issues

#### WiFi recommendations

- Ideally, the WiFi access point for Acurast should be separate and not used for other purposes.
- 5Ghz WiFi is preferable if users want to connect many devices as it offers more non-overlapping channels.
- If you run a massive farm, ensure your devices have the network capacity, even if they all are running deployments

#### Safety Recommendations

Running smartphones 24/7 — especially older or partially damaged devices - can accelerate wear and tear, particularly on the battery. Some users have reported battery swelling, which is a sign of degradation and potential risk. While there have been no known fire incidents among Acurast users, all operators, especially those running multiple devices, are strongly advised to take basic safety precautions:

- Avoid placing phones on flammable surfaces.
- Ensure adequate ventilation around devices to prevent overheating.
- Regularly check batteries for swelling or unusual heat. Remove phones with swelled batteries.
- Use certified chargers and power strips with surge protection.

Your safety is a priority - please run your setup responsibly.

---

## Processor Rewards

As a Compute Provider running Acurast Processors, you receive rewards for contributing your device's compute power to the network. The reward system is designed to incentivize reliable compute provision, high-quality hardware, and active participation in the Acurast ecosystem.

## Reward Types

### Deployment Execution

Tokens (cACU on Canary, ACU on Mainnet) are rewarded when a processor's compute power is used by developers to run code. Developers that deploy to the Acurast Cloud provide a reward for the compute power used. When your Processor has been selected, you'll receive part of that reward.

### Benchmark Rewards

Providers receive rewards based on the [benchmarks](/acurast-processors/benchmarks) of their participating devices. On Canary, a total of 12'500 cACU are distributed per epoch (roughly every 1.5 hours). These rewards are split up to the different benchmarks pools and each phone competes with the others in the 4 benchmark pools. Higher specs usually lead to higher Benchmark Rewards.

  
  Distribution per Benchmark Metric on Canary Network

### Cloud Rebellion

Join the [Cloud Rebellion](https://rebellion.acurast.com/) and harvest MIST points. Become a Rebel and cloud-harvest MIST (points) by completing quests, onboarding Processors, and inviting others to join the Rebellion.

### ~~Bootstrapping~~ (has been sundowned in favor of the Benchmark Rewards)

~~Receive 250 cACU each month in Bootstrapping Rewards. Run your Processor, connected to the internet, for a month and receive 250 cACU in bootstrapping rewards. You will receive a fraction of the full reward each hour.~~

---

## Roadmap

<ThemedImage
  sources={{
    light: useBaseUrl("/img/roadmap.png"),
    dark: useBaseUrl("/img/roadmap.png"),
  }}
/>

Major milestones in the 2025 roadmap include:

- Genesis Mainnet Launch, TGE (Q3 2025).
- Governance Activation for Decentralized Community Involvement.
- Codename Cargo (Compute Containers) for modularized workloads, making serverless deployments even easier to deploy and scale.
- Codename Cray (Compute Clusters) cluster of hundreds of devices enabling high-performance compute tasks capable of running even the largest LLMs available. Effectively mitigating the vertical compute limitation arising from working with phones.
- Furthermore, the future roadmap includes:

- Codename Bazaar (Compute Economy), creating an active decentralized compute economy for developers to distribute entire software solutions seamlessly without limitations.
- Codename Rice (Compute Futures), innovating long-term decentralized compute economic strategies. Allowing compute providers to leverage their infrastructure and support their future scaling.

Acurast’s growth strategy in 2025 is about activating a network effect at scale, where more phones bring more compute, more compute brings more builders, and more builders bring more value into the ecosystem. It’s a positive-sum loop powered by real-world demand, seamless integrations, and decentralized ownership, creating a compute marketplace flywheel.

Here’s how Acurast is scaling fast—and sustainably:

### 1. Mainnet Launch → Permissionless, Global Access

With the **Genesis Mainnet and TGE launching in Q3 2025**, Acurast becomes fully open, decentralized, and permissionless. Anyone with a smartphone can become a compute provider. Anyone with workloads, from solo builders to AI startups, can deploy confidential applications on a decentralized network backed by hundreds of thousands of real, verifiable phones.

Mainnet is Acurast’s on-ramp to true global accessibility, where compute is no longer gatekept by geography, capital, or centralized infrastructure.

### 2. Seamless Native Integrations with Major Web3 Ecosystems

Acurast is being embedded directly into the world's most active blockchain ecosystems, **Solana, Ethereum, Polkadot, and beyond**, so web3 developers can access decentralized, confidential compute as easily as calling a smart contract.

These native integrations mean:

- Developers can spin up secure compute from within their dApp flows
- Protocols gain censorship-resistant backends
- Ecosystems unlock AI, automation, and zero-knowledge tasks without centralized dependencies

This makes Acurast not just complementary, but critical infrastructure for Web3’s next phase.

### 3. Expanding Beyond Web3: Serving SMEs and Enterprises

While crypto-native at its core, Acurast is **not limited to Web3**. **SMEs and enterprise use cases** are actively being supported — especially around **confidential AI, confidential compute, and secure edge deployments:**

- Allowing enterprises to tap into AI without the fear of exposing business-critical and proprietary data by tapping into confidential AI compute
- Workloads requiring confidential compute without the complexity or cost of standing up traditional cloud infrastructure
- Enterprises in emerging markets lacking access to reliable data centers

Acurast offers these users **a confidential, on-demand, scalable, and cost-efficient alternative** to centralized compute.

### 4. Hyper-Onboarding of Smartphones at Global Scale

The onboarding strategy is rooted in mutual value creation. Initiatives like the **Cloud Rebellion**, major partnerships, and region-specific programs are designed to scale from 70,000 devices to over 1 million, converting dormant phones into high-value, secure nodes.

Each new phone adds network supply, but also unlocks new regions and new use cases, especially in areas where traditional compute is inaccessible.

### 5. Unlocking New Economic Layers

With milestones like:

- **Cargo** (modular compute containers)
- **Cray** (clustered high-performance compute)
- **Bazaar** (open compute marketplace)
- and **Rice** (long-term compute futures)

This is not just scaling tech—it's building an open compute economy, where compute is programmable, tradable, and ownable. Each upgrade compounds utility, revenue, and token demand.

### 6. Community-Driven Governance & Protocol Expansion

The Acurast community will shape protocol decisions post-mainnet through **on-chain governance** and a self-replenishing treasury. This turns users into stakeholders, and stakeholders into contributors.

**\*In short:** Acurast's 2025 growth strategy creates a flywheel:

**More devices → more demand → more utility → more contributors → more value.**

And at the center of that flywheel is a single insight: **you don’t need a data center to be part of the future of compute—just your phone.**

Now is the time to join.

---

## Staking Mainnet vs. Canary

:::info Under Review

The content on this page is currently under review and subject to change.

:::

Acurast operates two networks - Mainnet and Canary - each with different staking reward structures and purposes.

## Staking on Acurast Canary Network

Canary serves as Acurast's testing and experimental network, where new features are deployed and tested before moving to Mainnet. Staking rewards on Canary are significantly smaller, with only 1% of epoch inflation allocated to the Staked Compute Pool, while 99% goes to benchmark rewards. This distribution prioritizes onboarding new devices and testing network behavior over long-term staking incentives.

## Staking on Acurast Mainnet

Mainnet is Acurast's production network with a mature reward structure designed for long-term sustainability. Here, 70% of epoch inflation goes to the Staked Compute Pool (staking rewards), while the remaining inflation is distributed to: 15% Treasury, 10% Benchmark rewards, and 5% Collators (block producers). This higher allocation to staked compute reflects Mainnet's focus on securing reliable, committed compute capacity.

## Key Parameters Comparison (Mainnet vs. Canary)

| Parameter | Canary | Mainnet |
|-----------|---------|---------|
| Staked Compute Pool Allocation | 1% of inflation | 70% of inflation |
| Total Epoch Rewards | 8,561.64 cACU | 8,561.64 ACU |
| Staking Rewards per Epoch | 85.62 cACU (1% of 8,561.64) | 5,993.15 ACU (70% of 8,561.64) |
| Min Cooldown Period | 600 blocks (~ 1 hour) | 403,200 blocks (~ 28 days) |
| Max Cooldown Period | 28,800 blocks (~ 48 hours)| 19,353,600 blocks (~ 1344 days / 3.68 years)|
| Max Slashing per Epoch | 0.003424657534% of stake | 0.003424657534% of stake |

---

## Overview (Staked-compute)

:::info Under Review

The content on this page is currently under review and subject to change.

:::

Acurast Staked Compute: Compute Providers commit real hardware + token collateral for a chosen period of time. Delegators can stake with them, and together they share inflation rewards - but both risk slashing if the committer fails to support the deployed hardware long-term. This aligns the incentives to build the world's most accessible, reliable, and decentralized compute network.

## Why Staked Compute matters

### Ensuring Network Reliability

Acurast aims to become a global decentralized compute network where anyone can contribute compute power by running the Acurast processor app on dedicated (Core) or personal phones (Lite). The critical challenge is ensuring that provided compute remains consistently available and overall capacity does not degrade over time. Network liveness is essential for building a reliable and powerful infrastructure that developers and users can depend on.

### Commitment-Based Incentives

Staked Compute solves this through economic incentives. Compute Providers commit to supplying a specific amount of compute power - measured by four benchmark metrics - and stake Acurast tokens as collateral for a chosen duration. A stake is fundamentally a promise: providers promise to deliver compute and keep it online 24/7. If they fulfill their promise, they earn staking rewards based on their committed compute, stake size, and commitment duration. If they fail, they lose a portion of their staked tokens through slashing.

This creates "skin in the game" - real economic consequences that align everyone's incentives with network success. Providers are motivated to actively maintain their devices, keep them operational, and replace capacity when needed, because failing to do so means losing their staked capital.

### Building Stability for Developers

The staking mechanism creates the consistent, predictable compute capacity that developers need. Long-term commitments backed by financial collateral ensure reliability. When providers commit for months or years, developers can confidently build applications on Acurast knowing the compute infrastructure will be there when needed.

### Governance and Shared Benefits

In a later phase, staked tokens will grant voting rights in Acurast's governance process through the Acurast DAO. Stakes will represent both economic commitment and voting power in decisions about protocol upgrades, parameter changes, and network strategy.

The system creates a win-win ecosystem: Compute Providers earn rewards for reliable operation, delegators share in rewards without running hardware, and the network becomes more valuable and resilient as participation grows.

## Who can participate

There are two types of participants in Staked Compute:

### Committers

Committers run the Acurast processor app on actual hardware - smartphones- to provide compute and ensure the network's liveness. They stake their own tokens as collateral for their promised computation and receive staking rewards based on their chosen parameters (compute amount, stake size, and cooldown period). Committers can also accept delegations from other Acurast token holders and earn a delegation fee from these additional staked tokens.

If they fail to fulfill their commitment to provide the promised computation power, they can be partially slashed and their stake (and all of their delegators stakes) will be reduced by an defined amount of tokens.

### Delegators

Delegators are users who hold Acurast tokens but do not run hardware on the network. They believe in Acurast's value and want to support the network long-term by delegating their tokens (and voting rights) to committers of their choosing. Think of it as lending tokens to strengthen a Compute Provider's commitment. By delegating, they participate in their chosen committer's success and earn staking rewards (minus the committer's delegation fee).

Delegators also share the risk: if their committer fails to deliver on their commitment, delegators can be slashed proportionally. However, delegators can redelegate to another committer at any time if they're concerned about their chosen committer's performance.

Note that committers can also act as delegators, creating one delegation to themselves and additional delegations to other committers - useful for creating multiple stakes with different cooldown periods or risk profiles

---

## Slashing

:::info Under Review

The content on this page is currently under review and subject to change.

:::

## How Slashing Works

Slashing is a penalty mechanism designed to ensure committers keep their promise of providing consistent compute power over time. If a committer fails to stay online or their measured compute in any of the four benchmark metrics falls below what they committed - for example, because phones went offline and were not replaced - their stake gets slashed in proportion to the shortfall. For instance, if a committer promised 100 GB of RAM but only delivers 80 GB, they will be slashed proportionally for that 20% shortfall in the RAM metric.

This mechanism incentivizes providers to actively maintain their deployed Acurast phones and farms, ensuring they're always running and replacing capacity with equally powerful devices when needed. Both the committer and their delegators share this risk, as slashing affects all staked tokens proportionally.

### When Slashing Occurs

When a committer's Current Compute falls below their Committed Compute in any of the four benchmark metrics during an epoch, they become slashable for that epoch. Slashing must be triggered on-chain by a **Slasher**- anyone with an Acurast account who detects the violation.

### How Penalties Are Calculated

Once slashing is triggered, penalties are calculated independently for each Benchmark Metric where there's a shortfall. The slashing amount for each metric is determined by multiplying the stake amount by the maximum slash rate (0.003424657534% per epoch), the metric's weight, and the percentage shortfall.

For example, if a committer with a 1,000-token stake falls 50% short on RAM (which has a weight of 0.4615), they would be slashed 0.0079 tokens for that metric alone. If they have shortfalls across multiple metrics, each penalty is calculated separately and then summed together - though the total can never exceed 0.003424657534% of the stake per epoch.

### Slashing Examples

_Example 1: Complete Loss of Compute_

A committer has a 1,000-token stake. In an observed epoch, their Current Compute falls 100% short in all four metrics (CPU Single, CPU Multi, RAM, and Storage). Since they failed to provide any of their committed compute, they face the maximum penalty of 0.003424657534% of their stake per epoch, resulting in a total slash of 0.0342 tokens for this epoch. This breaks down as: 0.0079 tokens for CPU Single Core, 0.0079 tokens for CPU Multi Core, 0.0158 tokens for RAM, and 0.0026 tokens for Storage.

_Example 2 (fictional): Partial Loss of exactly 50% Across All Metrics_

A committer has a 1,000-token stake. In an observed epoch, their compute falls 50% short across all four metrics. They are slashed proportionally for this epoch: 0.0040 tokens for CPU Single Core, 0.0040 tokens for CPU Multi Core, 0.0079 tokens for RAM, and 0.0013 tokens for Storage - totaling 0.0171 tokens (0.00171% of their stake per epoch).

_Example 3 (realistic): Variable Shortfalls_

A committer has a 1,000-token stake. In an observed epoch, their compute falls short by different amounts: 12% in CPU Single Core, 15% in CPU Multi Core, 10% in RAM, and 12% in Storage. The resulting penalties for this epoch are: 0.000948 tokens for CPU Single Core, 0.001185 tokens for CPU Multi Core, 0.001580 tokens for RAM, and 0.000316 tokens for Storage - totaling approximately 0.0040 tokens slashed for this epoch.

### What Happens to Slashed Tokens

Of the slashed amount, 10% goes to the Slasher as a reward for detecting the violation, while the remaining 90% is immediately burned, reducing total supply and inflation.

## Slashing Impact

Importantly, committers still earn rewards for any metrics where they met their commitment; only metrics with shortfalls result in slashing. This means partial performance is still rewarded, while failures are penalized proportionally.

Just as rewards flow from committers to their delegators, slashing penalties also affect delegators proportionally based on their stake. When a committer is slashed, each delegator loses the same percentage of their delegated stake as the committer loses from their own stake. However, delegators can redelegate to another committer at any time if they're concerned about their chosen committer's performance.

---

## Staking FAQ

:::info Under Review

The content on this page is currently under review and subject to change.

:::

# Staking FAQ

## Understanding the Basics

### What is the Cooldown period?
When a stake is created, the Committer or Delegator chooses a cooldown length. The allowed range differs between networks: on Mainnet, cooldown periods range from 28 days to roughly 3.68 years, while on Canary, they range from 1 hour to 48 hours. When the user decides to unstake, they trigger the cooldown countdown. Only when the cooldown has ended can they withdraw their staked tokens. During cooldown, the reward weight and vote weight are reduced to 50% of the previous value. See the [Mainnet vs. Canary comparison](/staked-compute/mainnet-vs-canary) for exact block values.

### What is the reason for the Cooldown Period to exist?
The cooldown period protects the network from sudden losses of compute capacity. Without it, committers could instantly withdraw their stakes and shut down their hardware, leaving the network vulnerable to instability. The cooldown gives the network time to adjust and allows other providers to fill the gap. It also ensures that committers remain committed to their promise: during cooldown, they must continue maintaining their full committed compute (with full slashing risk) even though their rewards are reduced to 50%. This design discourages impulsive exits and rewards long-term commitment, which is essential for building a reliable, predictable compute network that developers and users can depend on.

### What are Risk/Reward Tradeoffs of Staking with Acurast?
Staking with Acurast follows a clear principle: higher commitment equals higher rewards, but also higher risk. Committers who commit more compute, stake larger amounts of tokens, and choose longer cooldown periods earn proportionally greater rewards - but they also face greater slashing penalties if they fail to maintain their committed compute levels. For example, committing 80% of your measured compute yields more rewards than committing 50%, but falling short on that 80% commitment results in larger slashing penalties. Delegators face a similar tradeoff: they can earn staking rewards without running hardware, but they share in their chosen committer's slashing risk. The key is finding the right balance - commit what you can reliably maintain over the long term. Conservative commitments (lower compute percentage, shorter cooldown) offer lower rewards but also lower risk, while aggressive commitments maximize rewards but require consistent, reliable operation of your hardware.

## Getting Started with Staking

### Why do I only see one slider to Commit Compute, when the four metrics are treated separately anyway?
Even though any stake is basically a separate committement for each of the four of the benchmark pools (CPUs, CPUm, RAM, Storage), the staking frontend only shows one slider for simplicity reasons. For example, if the Committer selects to stake 50% of the measured compute, his stake is a committment to keep up 50% of the compute per Benchmark Metric Pool. Means to upkeep 50% of the CPU Single Core Benchmark Metric, 50% of the CPU Multi Core Benchmark Metric, 50% of the RAM Benchmark Metric and 50% of the Storage Benchmark Metric over the lifetime of the stake.

### Why can I only commit 80% of my measured Compute?
The maximum a user can commit is capped at 80% of the currently total measured compute, in order to prevent early Slashings if the Committer's Compute is fluctuating due to processors going offline.

### Why can I only stake 999 tokens if I have 1000?
When a user stakes tokens, all of these tokens will be locked and cannot be moved. This means that the users account won't be able to pay for gas fees caused by processors to report heartbeats and deployment execution reports. This would result in a situation where this account won't be able to receive rewards from benchmarks or computation without getting additional tokens. Therefore a safeguard deposit of 1 cACU / ACU was introduced.

### What is the maximum of tokens a user can stake?
A committer can stake as much as they want up to the limit defined by their compute metric × the allowed ratio. The higher their benchmark (more or stronger devices), the more stake they can back it with. The committer's own stake cannot exceed some multiple of their compute metric capacity (benchmark score). This prevents someone from locking an enormous amount of ACU behind a tiny phone and unfairly capturing rewards.

## Managing Your Stake

### Can a stake be reduced while it exists?
No. Once a stake is set up, it can only be extended - by a longer cooldown period, committing more computation, or adding more tokens. None of these parameters can be reduced in an active stake.

### How many stakes can a Committer have?
A committer can only have one own stake, but they can delegate one additional stake to themselves and they can delegate unlimited stakes to other committers (one stake per committer), allowing them to create stakes with different cooldown periods and size.

## Delegation

### How many delegations can a Committer accept?
While the number of delegations is not limited, a committer's delegated stake is limited dynamically by several parameters, in dependence of their current delegations, the state of these delegations and their own staked compute.

### What happens to the Delegator's stake when the Committer starts cooldown?
Delegators can only choose a cooldown period that is shorter (never longer) than the selected Committer's cooldown. For example, if the selected Committer choses a cooldown of 6 months and the Delegator chose 2 months, once the Committer starts cooldown, it will take 4 months until the Delegator's cooldown automatically starts as well.

Delegators can see when their Committers start cooldown and can redelegate their stake to a different Committer, regardless of whether their own cooldown period has already started.

### What happens to the Delegator's stake when their Committer is slashed?
Delegators are affected by slashing and will lose a pro rata share of their stake if their Committer is slashed. Delegators can choose to redelegate their stake to a different Committer.

## Rewards

### How much in rewards can a Committer or Delegator expect?
Staking rewards in the Acurast network are dynamic and cannot be precisely predicted in advance, as they depend on the collective behavior of all participants. Your individual rewards are determined by your share of the total network commitmen - calculated from your benchmark scores, stake size, and cooldown duration relative to all other stakers. As more participants join with varying parameters, or as existing participants adjust their commitments, the reward distribution shifts accordingly. Additionally, rewards are split across four separate benchmark metric pools, meaning your performance in each metric directly impacts your share of that pool's rewards.

Once the system goes live and staking activity stabilizes, estimated Annual Percentage Rates (APR) will become available to help participants gauge potential returns. However, the fundamental principle remains: stronger hardware, larger stakes, and longer commitment periods will always yield proportionally higher rewards compared to participants with lower commitment levels.

---

## Staking Glossary

:::info Under Review

The content on this page is currently under review and subject to change.

:::

# Staking Glossary

## Core Concepts

### Compute Provider
(aka Manager): A user that runs the Acurast processor app on one or more phones.

### Committer
(aka Staker, Manager, Compute Provider): A user that is a Compute Provider who commits compute by Staking.

### Delegator
Users that are Staking Acurast tokens with Committer by attaching their stake to a Committer's stake.

### Stake
A Committers commitment, backed by an amount of Committed Compute, an amount of Acurast tokens and a Cooldown period of a chosen length.

## Compute Metrics

### Benchmark Metrics
Four standardized tests that measure a device's computational capacity: CPU Single Core (0.2307 weight), CPU Multi Core (0.2307 weight), RAM Size (0.4615 weight), and Storage Size (0.0769 weight). These metrics are measured during every device heartbeat and reported on-chain to determine Current Compute and calculate rewards and slashing.

### Current Compute
The amount of compute that was measured across all processors in the last epoch for a specific Compute Provider. During that epoch, all devices ideally had written three heartbeats including three benchmark results. In order to determine the Current Compute for an epoch the ??? latest ??? recorded heartbeat off all devices are being used.

### Committed Compute
The amount of compute a Compute Provider commits to providing during the lifetime of a Stake, including its Cooldown period.

### Stake Health
The health state of a Stake, regarding the Current Compute in relation to the Committed Compute.

## Staking Mechanics

### Cooldown
A countdown triggered when a user chooses to exit their stake. During the cooldown period, reward weights are reduced to 50% while slashing risk remains at 100%. When the cooldown period ends, the stake can be finalized and tokens become unlocked and transferable again. The cooldown is measured in blocks and ranges differ by network: Mainnet (28 days to ~3.68 years) and Canary (1 hour to 48 hours). See [Mainnet vs. Canary](/staked-compute/mainnet-vs-canary) for details.

### Unstake
The process of signaling the intention to end a Stake. Unstaking triggers the Cooldown.

### Finalize
The process of withdrawing a stake after the cooldown period has ended, returning the unlocked tokens and any unclaimed rewards to the staker or delegator. Also called "claiming a finalized stake."

### Recommit
After starting cooldown on a stake, users can choose to recommit if they change their mind. Recommitting immediately restores reward weight and vote weight to 100% and resets the cooldown countdown, returning the stake to its active state.

## Rewards & Penalties

### Total Staking Rewards
The rewards paid to all Stakers by the inflation of the Acurast Blockchain per epoch.

### Autocompounding
Adding accrued rewards to the existing Stake instead of claiming them.

### Claiming rewards
Requesting the accrued rewards to be sent to the Staker or Delegator.

### Slashing
A penalty that can be forced upon Committers, if they do not succeed in keeping up the amount of Compute they committed to (the Committed Compute).

### Slasher
A user that triggers Slashing for a Stake that did not provide enough Compute to match its Committed Compute.

### Slasher's Reward
A percentage of the slashed amount, that is given to the Slasher as a reward for detecting a violated compute commitment.

## Delegation

### Redelegate
Detaching a running Delegation from one Committer and attaching it to a new Committer. Can only be done if the new Committer shares the exact same or higher parameters (Committed Compute, Staked Tokens, Cooldown duration) than the previous Committer and is not in Cooldown.

### Delegation Fee
A fee Committers can set once upon creating a Stake and will receive from the rewards of the Delegations attached to their stake. The Delegation fee can not change during the lifetime of a Stake.

### Delegation Capacity
The amount of delegations a Committer can accept.

## Time & Measurement

### Epoch
One epoch equals 900 blocks (approximately 1.5 hours).

### Heartbeat
A sign of life that all Acurast Processors emit in the form of a transaction that is sent to the Acurast blockchain. The heartbeat information also contains the results of a new benchmark test. Usually heartbeat is emitted and recorded once per cycle, which is three times per epoch. If a processor is offline, it will not emit heartbeats.

---

## Staking Mechanics

:::info Under Review

The content on this page is currently under review and subject to change.

:::

## How to Stake

On the Staking page in the Acurast Hub, users can stake and have an overview over their Stakes and Delegations.

To create a stake, Compute Providers (aka Committers) have to:

1. Compute: select the amount of Compute they are comfortable to commit.
2. Cooldown: select the Cooldown period. The cooldown period is measured in blocks. The Staking Frontend also provides an estimate expressed in time (days etc.)
3. Tokens: Select the amount of tokens to stake
4. Compound: Select if Autocompoundung is ON or OFF

To do a delegation, Delgators have to:

1. Committer: Select a Committer
2. Cooldown: Select a Cooldown period
3. Tokens: Select the amount of tokens to delegate
4. Compound: Select if Autocompoundung is ON or OFF

## How Compute is measured

### What is Current Compute?

The measured compute of a Compute Provider is displayed as **Current Compute** on the Staking frontend. It represents the total computational capacity across all of a provider's devices, broken down into four benchmark metrics: CPU Single Core, CPU Multi Core, RAM, and Storage.

### How Benchmarks Are Measured

Compute is measured through four benchmark tests conducted on every device running the Acurast processor. These tests run automatically during each device heartbeat (every 30 minutes) and the results are reported on-chain. At least one valid benchmark report per epoch (900 blocks / roughly 90 minutes) is required to maintain a device's measured compute. Read more about the technical aspects of the benchmarks [here](/acurast-processors/benchmarks).

### Benchmark Metric Weights

Each of the four benchmark metrics has a weight assigned to reflect its importance to the Acurast network's computational requirements and resource priorities:

| Benchmark Metric | Weight |
|-----------------|--------|
| CPU Single Core | 0.2307 |
| CPU Multi Core | 0.2307 |
| RAM | 0.4615 |
| Storage | 0.0769 |

These weights ensure that providers are incentivized to maintain balanced, high-quality compute resources, with RAM being the most heavily weighted metric due to its critical role in application performance.

The Staking frontend is showing the four metrics, as measured in the last epoch for each Committer.

## Rewards

Staking rewards are generated from Acurast's token inflation and distributed every epoch to committers and delegators who support the network. The amount each participant earns depends on three key factors: the strength of their committed compute (measured by benchmark scores), the size of their staked tokens, and the length of their cooldown period. In short: stronger hardware, bigger stake, longer commitment = bigger rewards.

## Reward Flow

Staking Rewards trickle down through several pools and are split up:

**Inflation → Staked Compute Pool**

Each epoch, a share of the inflation (70% on Mainnet / 1% on Canary) goes to the Staked Compute Pool. These reward tokens are created by block producers and minted directly into the Staked Compute Pool.

**Staked Compute Pool → 4 Benchmark metric pools**

From the Staked Compute Pool, the reward tokens are further split between four Benchmark Metric Pools according to the Benchmark Metric Weights

**Benchmark Metric Pools → Committers**

The share of rewards each committer gets depends on a score calculated from following factors, which can be chosen or influenced by the committer when creating the stake.
The share of rewards each committer gets depends on a score calculated from following factors, which can be chosen or influenced by the committer when creating the stake.

In short: stronger hardware, bigger stake, longer commitment = bigger rewards.

The reward split is calculated per Benchmark Metric Pool, and the relative score of a participant $c$ compared to other participants is calculated as

$$
\text{committer\_score}_c = \min\left(\sqrt{\text{metric}_c \times \text{stake}_c \times \frac{\text{cooldown}_c}{\text{max\_cooldown}}}, \; T \times \text{metric}_c\right).
$$

The minimum ensures that the stake backing a single farm stays within a reasonable range, derived from a global $\text{target\_weight\_per\_compute}$

$$
T := \frac{0.8 \times \text{total\ supply}}{\text{total\ benchmarked\ metric}}
$$

that expresses the ideal staking rate given the current compute offered over our system.

We later refer to this product by $\text{weight}$

$$
\text{weight} := \text{stake} \times \frac{\text{cooldown}}{\text{max\_cooldown}}
$$

**Committer's Share → Self vs. Delegators**

A committer's reward is split between their own weight and the total weight of their delegators, relative to the token amounts and chosen cooldown periods.

**Delegators Split**

The remaining delegator rewards are split between all delegators of the same committer, according to each delegator's weight. Also the delegation fee is split off to the Committer. The following factors influence delegation rewards for a delegator $d$ towards a committer $c$:

$$
\text{delegator\ reward}_d = \text{delegator\ weight}_d - \text{delegation\ fee}_c - \text{potential\ slashings}_c
$$

### Where the rewards come from

Acurast inflates its token supply every year, by 5% (currently, can be changed by governance). That inflation is split between the following pools:

**On Mainnet:**
- 70% → Staked Compute Pool (The rewards for Staking)
- 15% → Treasury
- 10% → Benchmark rewards (Base rewards processors, shared in relation to the benchmarks, independent from Staking)
- 5% → Acurast blockchain block producers (Collators aka Validators)

<ThemedImage
  sources={{
    light: useBaseUrl("/img/inflation.png"),
    dark: useBaseUrl("/img/inflation.png"),
  }}
/>

**On Canary:**
- 1% → Staked Compute Pool (The rewards for Staking)
- 99% → Benchmark rewards (Base rewards processors, shared in relation to the benchmarks, independent from Staking)

### When are rewards distributed

Rewards are distributed to every committer and their delegators once every epoch (one epoch is 900 blocks) with the first reported heartbeat of the committer.

## Rewards to be Expected

Staking rewards in the Acurast network are dynamic and cannot be precisely predicted in advance, as they depend on the collective behavior of all participants. Individual rewards are determined by the participant's share of the total network commitment - calculated from benchmark scores, stake size, and cooldown duration relative to all other stakers. As more participants join with varying parameters, or as existing participants adjust their commitments, the reward distribution shifts accordingly. Additionally, rewards are split across four separate benchmark metric pools, meaning performance in each metric directly impacts the share of that pool's rewards.

Once the system goes live and staking activity stabilizes, estimated Annual Percentage Rates (APR) will become available to help participants gauge potential returns. However, the fundamental principle remains: stronger hardware, larger stakes, and longer commitment periods will always yield proportionally higher rewards compared to participants with lower commitment levels.

## Impact of Cooldown on Rewards and Slashings

### Reduced Rewards During Cooldown

When a committer triggers the cooldown period to exit their stake, both their reward weight and their delegators' reward weights are immediately reduced to 50% of the previous value. This means that throughout the entire cooldown period, the committer and all their delegators will earn only half the staking rewards they earned before cooldown was initiated. This reduction reflects the reduced commitment to the network, as the participant has signaled their intention to withdraw.

### Slashing Remains at Full Rate

Importantly, while rewards are halved during cooldown, slashing penalties are not reduced. Committers must continue to maintain their full committed compute throughout the cooldown period, and any shortfalls will result in standard slashing penalties calculated at 100% of the normal rate. This ensures that committers cannot reduce their hardware commitment once they've initiated cooldown - they must maintain their promised compute capacity until the cooldown period ends and they finalize their stake.

## Staking Lifecycle

**Committer:**

* **Start staking:** Committer chooses the amount of computation to commit, tokens to stake, and cooldown length, then creates a stake.
* **While staking:** Committers can add more tokens to the stake, increase duration and committed compute, and either compound or withdraw rewards. They must maintain their committed compute level to avoid slashing.
* **Exit staking:** Committer triggers cooldown (reducing rewards to 50% but maintaining full slashing risk) and waits until it ends.
* **Finalize (Withdraw/Claim):** After cooldown ends, committer finalizes the stake, withdrawing the unlocked funds and any unclaimed rewards.

**Delegator:**

* **Start Staking:** Delegators choose one or several committers to delegate to, then select the amount of tokens and cooldown period (which cannot exceed their chosen committer's cooldown).
* **While staking:** Delegators can add more tokens, increase duration, compound or withdraw rewards. They can also redelegate their stake to a different committer with equal or greater parameters (committed compute, stake size, and cooldown duration).
* **Exit staking:** Delegator triggers cooldown (reducing rewards to 50%) and waits until it ends.
* **Finalize (Withdraw/Claim):** After cooldown ends, delegator finalizes the stake, withdrawing the unlocked funds and any unclaimed rewards.

## Reward compounding (Autocompound)

When creating a stake, committers and delegators can choose whether their staking rewards should be automatically compounded (immediately added back to their stake) or made available for withdrawal. If they choose not to autocompound, rewards accumulate and can be withdrawn at any time - users are then free to move these rewards or manually stake them again. Autocompounding simply automates this process, maximizing reward growth over time without requiring manual action.

---

## Staked Compute

:::caution Under Review

The specifics on this page are currently under review and subject to change.

:::

## TLDR — why this matters

- Staked compute plays a significant role for Acurast: 70% of the inflation is allocated to "Staked Compute"
- Accessible first design: Onboard smartphone compute without token purchase or gatekeepers
- People without hardware can still receive rewards by delegating their stake to compute providers
- Compute providers can accept delegation and receive additional rewards
- Staked compute can be restaked

## Introduction

In a Decentralized Physical Infrastructure Network (DePIN) network like Acurast, tokens play an integral role in incentivizing behaviour that the network considers beneficial, such that it can achieve its intended mission. In Acurast’s case, this mission is to become the largest global compute network, accessible by anyone, anywhere, all without gatekeepers. More on that ["It's time to rethink compute"](https://acurast.medium.com/its-time-to-rethink-compute-thoughts-from-our-co-founder-alessandro-de-carli-f4fba2b68b97).

As a decentralized protocol, Acurast is secured through economic incentives with nominated proof of stake, and additionally taps into the shared security of Polkadot. However,, this protocol differs from others in its novel approach to solving the challenge of liveliness of the provided compute. We introduce a new concept called “Staked Compute”, making it an evolution in consensus algorithms, combining Proof of Stake with the Quality of Service of the compute provided.

First, let’s clarify where these staking incentives are coming from before getting into the details of the staking mechanics:

<ThemedImage
  sources={{
    light: useBaseUrl("/img/inflation.png"),
    dark: useBaseUrl("/img/inflation.png"),
  }}
/>

## Inflation

As no central party provides the required infrastructure, decentralized systems like Bitcoin, Ethereum, and others solved the incentivization problem by simply minting tokens whenever a new block is created. Usually, consensus rules allow whoever creates the new block to include a transaction that mints a predefined amount of tokens.

This model has similarities with that of Acurast. There is a major difference — instead of just rewarding the block producer, the consensus rules enforce that the larger part of the inflation is distributed to different pools with specific purposes:

- 70% of the inflation will go to the staked compute pool
- 15% of the inflation will go to the on-chain treasury
- 10% of the inflation will go to the compute pool
- 5% of the inflation will go to the block producers. (this can be kept low because of restaking and shared security)

It’s essential to notice that participation in the compute and staked compute pools is not mutually exclusive, meaning there is an automatic participation in the compute pool if the user participates in the staked compute pool, but not vice versa.

At genesis, Acurast will start with a fixed inflation of 5%; however, through on-chain governance votes, this inflation as well will be adaptable. Also the proposed splits between the pools

Let’s describe the parameters of these pools in more detail:

### On-Chain Treasury Pool

As outlined in the tokenomics of Acurast, the on-chain treasury receives at genesis 24% of the [total supply](https://acurast.medium.com/acurast-tokenomics-fueling-decentralized-compute-with-acu-be4f33632f41). To ensure the protocol stays future proof, maintained, and further developed, the protocol inflation continuously replenishes this treasury pool of tokens. An on-chain governance process decides whether to fund proposals put forward by the token holders or simply burn all the tokens in the treasury.

### Compute Pool

For the highest possible accessibility, the design decision was made that users should be able to onboard compute power based on the hardware of smartphones provided by individuals without the need to acquire Acurast tokens first.

The compute pool exists to incentivize any phone-based compute onboarded to Acurast. The weight a phone is assigned in the pool depends on the score of the benchmark the hardware can achieve. [Read more here](/acurast-processors/benchmarks). Unless a phone is executing an assigned workload by the protocol, it defaults to a predefined workload that every phone in the network runs, the benchmarking report that is submitted to the protocol with a heartbeat transaction in a 30-minute interval.

The purpose of this pool is to incentivize onboarding new compute to the network. A remaining issue with this pool is the long-term availability and reliability of compute.

That is where the staked compute pool comes into play.

### Staked Compute Pool

As a global compute network, the availability and reliability of compute play a major role. For that reason, most of the inflation is assigned to the staked compute pool. Similar to the compute pool, the weight of a pool participant depends on the phone’s benchmark report. Still, the expected future availability of the compute has to be set by staking a collateral deposit of ACU. This collateral ensures that these compute providers can be held accountable, if the provided compute becomes no longer accessible. The next section will explain how the staked compute mechanics work.

### Staked Compute

The general compute onboarded to Acurast receives two security properties by design, these are a must for a decentralized compute network:

- Verifiability: Assuring that the hardware actually exists, is genuine, and the compute execution cannot be tampered with.
- Confidentiality: Ensuring that the provider of the compute hardware cannot inspect the execution or extract any data from it.

In Acurast’s case, these two properties are provided by a Trusted Execution Environment (TEE) that resides in the hardware security module that phones are equipped with. A device attestation proof signed by the TEE, with a device manufacturer provided private key, is verified on a protocol level and only accepted, if the devices’ integrity is given, meaning that the hardware is in the same condition as when it left the factory and the operating system with its checks in place e.g., if the phone is rooted or has an unlocked bootloader.

However, the TEE cannot provide liveliness guarantees, meaning that this environment cannot protect against loss of power or network connection, in short, liveliness. This makes it necessary to introduce an additional layer of security through economic incentives on the protocol level, which is where Staked Compute comes into play.

As the name suggests, in addition to specifying the future compute availability, the compute provider assigns a certain stake to their commitment. The stake ensures that there is a strong incentive for the compute provider to actually comply with their commitment, making the need for a central authority completely obsolete.

### Slashing

If the compute provider breaches their commitment, their stake will be slashed. The slashed amount depends on how long the compute provider has breached their commitment. The Slashing mechanism is only applicable to unscheduled downtimes; for in advance scheduled maintenance, there is no slashing penalty. It’s also important to notice that slashing doesn’t happen immediately. If a heartbeat is missed, there is a grace period. The technical specification will share exact details on the slashing mechanism and the amounts.

### Participation

To participate in the staked compute pool, one must define how long the compute provider will provide that compute going forward. The compute provider can decide to commit compute (up to a maximum of 80% of their last benchmark average score over the previous 24 hours) for one or more epochs, where one epoch is equal to 28 days, up to a maximum of 16 epochs (16 \* 28 = 448 days). Every compute provider deciding to create staked compute is eligible for a share of the inflation assigned to the pool relative to the other pool participants. The weight of a participants share is defined as:

```
staked_compute_weight = benchmark_in_heartbeat * commit_time * stake_amount
```

**While this formula looks simple, the incentivization effects are powerful:**

- Compute providers who commit more compute for a longer period are further incentivized.
- There is a high incentive to onboard compute because the optimal weight is reached if all three factors are high, if i.e., if only the stake is large but the compute is low, someone else with a smaller stake but more compute is prioritized.
- Creating a fair setup benefiting the protocol, whoever is willing to commit compute for a long period of time is equally rewarded the most. This ensures stability and reliability.

It’s important to note that `“benchmark_in_heartbeat”` should be seen as the aggregation of all phones of a given compute provider, not just a single one. Meaning even if a compute provider will experience a malfunction on one phone, they can compensate with another phone.

### Stake Delegation

Not every staker will need to have their own hardware setup. They will be able to receive rewards from staking by delegating their stake to other compute providers on the network.

Every compute provider can stake and accept a delegated stake. As shown in the previous formula, the total amount of stake “stake_weight” is the sum of the own + delegated stake. To avoid centralisation and align slashing, the target is set at a 9:1 ratio of own stake vs. allowed delegated stake. If a compute provider decides to allow delegations, they must specify a fee applied programmatically on a protocol level during the reward distribution to the delegators.

### Restaking

Restaking is a concept that became very popular in the web3 world because of projects like i.e. [EigenLayer](https://www.eigenlayer.xyz/). The main advantage of restaking is its capital efficiency. Instead of having a stake just sitting “idle” you can use that stake instead for other functions.

As staked compute already aligns with the long-term thinking of the protocol and its mission, stakers will be able to use their stake directly as weight for on-chain governance as well as block producer nominations. The beauty of having restaking as an integral part of the protocol is that not only it will be more capital efficient, but it will also offer the user a way simpler user experience.

---

## Tokenomics

:::caution Under Review

The specifics on this page are currently under review and subject to change.

:::

Acurast is the decentralized compute network designed to power the emerging decentralized compute economy by aligning developers, compute providers, and end-users around shared incentives.

At the heart of Acurast is the ACU token and economic model, fueling a secure, scalable, and decentralized compute ecosystem while incentivizing active collaboration and sustainable growth.

Also, with tokenomics, the focus is on a sustainable community-first approach.

## Key Highlights

- **Initial Supply at TGE:** 1,000,000,000 ACU
- **Adaptive inflation:** between 1% and 5% annual inflation
- **Only 6.5% allocated to early backers** — while important for funding and supporting development all the way to mainnet, this allocation was kept very low in order to facilitate a fair launch of the token.
- **Nearly 70%** of tokens are allocated to the community or community-supporting purposes (Community Treasury, TGE Community Activation, Operational Funds, Liquidity Provision)
- **Team and Advisors have the longest lock-ups,** aligning them with the long-term mission of the project.

By capping early backers at just 6.5% and allocating the majority of tokens to the community and community-supporting initiatives, the token distribution **puts the ecosystem interests first,** acknowledges early contributions to the broader crypto ecosystem, and **fosters the creation of services and products** on top of Acurast — ultimately supporting the project's roadmap and long-term objectives. Moving the needle again to decentralization, because decentralized compute is not for the few but for the many.

## Genesis Token Allocation

### Allocation Categories

**Early Backers:** A small, diverse group providing initial funding to ensure the protocol reaches mainnet maturity without heavy institutional influence.

**Team and Advisors:** Tokens for the core contributors of the protocol, encompassing employees, advisors, founders and future key team members, with the longest lock-up; this allocation is structured to align for long-term incentives.

**TGE Community Activation:** Tokens from the participation of the launchpad token launch, canary token conversions, airdrops and additional broader activation of the community on TGE.

**Community Treasury:** With decentralization in mind from the first day, a large part of the tokens are allocated towards the community treasury, allowing ACU holders to determine through on-chain governance the future development of the protocol and support significant contributions via governance proposals.

**Operational Funds:** Strategic funds with the mandate to foster protocol acceleration and growth, governed by the Acurast Association council.

**Liquidity Provision:** This allocation is used exclusively to ensure enough liquidity of the Acurast Token on centralized and decentralized exchanges.

### Token Allocations

| Category             | Supply | Token Amount | Available at TGE | Linear Vesting |
| -------------------- | ------ | ------------ | ---------------- | -------------- |
| Early Backers        | 6.5%   | 65'000'000   | 0%               | 24 months      |
| Team and Advisors    | 24%    | 240'000'000  | 0%               | 36 months      |
| Community Activation | 24%    | 240'000'000  | 100%             | 0 months       |
| Community Treasury   | 24%    | 240'000'000  | 100%             | 0 months       |
| Operational Funds    | 11.5%  | 115'000'000  | 0%               | 24 months      |
| Liquidity Provision  | 10%    | 100'000'000  | 100%             | 0 months       |

Only tokens allocated to the community and community support will unlock at TGE. All other allocations are locked for at least 24 months after TGE and are released gradually over that period.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/tokenomics/65.png"),
    dark: useBaseUrl("/guide/tokenomics/65.png"),
  }}
/>

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/tokenomics/66.png"),
    dark: useBaseUrl("/guide/tokenomics/66.png"),
  }}
/>

## Token Utility

**Network Fees:** The Acurast network, a Proof of Stake blockchain, acts as an orchestrator and settlement layer for the decentralized compute economy. To interact with the Acurast network, ACU is required for transaction fees.

**Staking:** While compute is secured by design, an additional layer of economic security is added to the network by staking through Processors. Stakers receive fees from the network as rewards for providing economic security to the network. Every ACU holder can participate in staking without having to run their own Processor through Delegation.

**Settlement:** ACU acts as a unified settlement token for the system to assign and measure reputation and quality of service of the provided compute. A 30% burn is applied on every settlement transaction to avoid reputation score tampering. This mechanism is abstracted from the end user, making payment for decentralized compute on Acurast possible in any token.

**Governance:** Holders of ACU can engage in protocol governance by voting on a variety of proposals brought forward by the community, guiding the development of the protocol and its components, and ensuring true decentralization and future-proof evolution by design.

## Inflation

Inflation is what makes the Acurast process sustainable by rewarding active participation in the protocol and creating incentives to be run as a decentralized protocol indefinitely. The protocol sets inflation between 1% and 5% annually, depending on various on-chain metrics, and can be further adapted through governance votes.

---

## Wallets

A non exhaustive list of wallets supporting Acurast:

- [Metamask](https://www.metamask.io)*
- [SubWallet](https://www.subwallet.app/)*, see a comprehensive guide here: **[Use SubWallet with Acurast ↗](/wallets/wallets-subwallet)**
- [Talisman](https://talisman.xyz/)*, see a comprehensive guide here: **[Use Talisman with Acurast ↗](/wallets/wallets-talisman)**
- [Ledger](https://www.ledger.com/)*, see a comprehensive guide here: **[Use Ledger with Acurast ↗](/wallets/wallets-ledger)**
- [AirGap](https://airgap.it/), see a comprehensive guide here: **[Use AirGap with Acurast ↗](/wallets/wallets-airgap)**
- [WalletConnect compatible wallets](https://reown.com/)
- [Phantom](https://phantom.com/)

\* Recommended wallets

---

## AirGap Wallet

:::danger IMPORTANT

AirGap Wallet can currently only be used to track the balance of an Acurast account, not to connect to the Acurast Hub or to sign transactions. The AirGap team is currently implementing signing and connections to the Hub.

:::

# Secure offline setup of AirGap for Acurast

AirGap is a self-custody solution, developed by Papers AG, with a two-device approach:

- **Offline signer** holding the private keys
- **Online wallet** to execute transactions

Signing payloads are transported via QR codes.

## 1. Make the offline phone ready and install AirGap Vault

:::info

You can also download AirGap Vault from the Google Play or Apple App store and take the phone offline afterwards.

For the best possible security, follow the steps below.

:::

1. Get a new phone that will only be used for offline signing and never has a connection to the internet.
   - An Android phone is recommended.
   - Also get a fresh USB stick which you can connect to the phone.
2. You don't need to log in to a Google Account, but you need to set a **PIN code, pattern, fingerprint or face-id** for your device.
3. Start the phone and update it to the latest OS.
4. Take the phone offline, remove all previous Wi-Fi connections (so it can't connect accidentally), and set it to **Airplane Mode**.
5. Download the latest [AirGap Vault APK from GitHub](https://github.com/airgap-it/airgap-vault/releases) and move it to the USB stick.
6. Plug it in and install the APK on your phone, give the necessary permissions.

## 2. Install AirGap Wallet on the online phone

7. On the online phone, install AirGap Wallet from the [Google Play Store](https://play.google.com/store/apps/details?id=it.airgap.wallet) or [Apple App Store](https://apps.apple.com/app/airgap-wallet/id1420996542).

## 3. Generate a new secret

8. Open the AirGap Vault app, skip through the initial messages and accept the disclaimer.
9. Select the **offline configuration** and skip to the screen where you can generate a new secret.
10. Select **Generate** and give permissions for camera and microphone.
11. Go through the entropy generation process (touch, gyro, camera, mic).
12. Write down the secret recovery seed phrase and store it according to best practices.
    - ❌ Do not store the seed phrase on an online device.
    - ❌ Do not store it in an online password manager.
13. Verify the written-down recovery seed phrase.
14. Set an **encryption password** and ensure you always remember it.
    - ✅ You may use a password manager here (but never store the seed in it).

## 4. Generate an Acurast account and sync with AirGap Wallet

15. Add an Acurast account and confirm with your encryption password and the device PIN. A new Acurast address will be generated.
16. Click on the new Acurast account, then click on the **AirGap Wallet** button → a QR code will be displayed.
17. Open AirGap Wallet and scan the QR code of the offline device.
    - The account's **public key** will be imported into your AirGap Wallet.

## 5. Verify the recovery

18. In AirGap Vault, go back to the main screen.
19. Click on the card of the newly generated secret.
20. Tap on the 3-dot menu → **Secret management** → scroll down and select **Delete** → Confirm Secret Removal.
    - The secret is now wiped from the offline phone.
21. Go back to the main screen and select **Import**.
22. Import the secret recovery phrase from your written notes.
23. Set the same encryption password as before.
24. Once done, generate an Acurast account.
25. Compare the recovered account to the account synced in step 17.
    - ✅ If they match → recovery successful.
    - ❌ If not → delete and start again from step 10.

## Important to know

1. The **encryption password** set in step 14 will determine the derived account.
   - If you forget it, recovery is impossible even with the seed phrase.
2. Follow best practices when storing the seed phrase:
   - Example: metal plate in safe, paper note in safe, ensure you can identify the right seed.
3. Do not store the encryption password in the same place as the recovery seed.
4. More documentation: [AirGap Support](https://support.airgap.it/)
5. **NEVER** connect your offline phone to the internet.
   - If you must, first completely remove the secret from the phone.
6. If you need to copy the account address, copy it from the online phone with AirGap Wallet.

## Resources

- [AirGap Step by Step Setup Guide](https://support.airgap.it/guides/step-by-step-guide/)
- [AirGap Vault Releases on GitHub](https://github.com/airgap-it/airgap-vault/releases)
- [AirGap Wallet Releases on GitHub](https://github.com/airgap-it/airgap-wallet/releases)
- [AirGap Wallet on Google Play Store](https://play.google.com/store/apps/details?id=it.airgap.wallet)
- [AirGap Vault on Google Play Store](https://play.google.com/store/apps/details?id=it.airgap.vault)
- [AirGap Wallet on Apple App Store](https://apps.apple.com/app/airgap-wallet/id1420996542)
- [AirGap Vault on Apple App Store](https://apps.apple.com/app/airgap-vault/id1417126841)

---

## Ledger Hardware Wallet

### Create an Acurast address with Ledger (and SubWallet)

This guide explains how to create an address with [Ledger](https://www.ledger.com/) hardware wallet. Ledger provides secure cold storage for your crypto assets by keeping your private keys offline.

:::info

Acurast is built on Polkadot technology, so you'll need to install the Polkadot app on your Ledger device to manage Acurast accounts.

This guide is written for **Ledger hardware wallets** with the **SubWallet** extension in a **Chromium based browser**. Talisman, Polkadot.js and Firefox do not fully support this setup at this point in time.

:::

### Prerequisites

Before you begin, ensure you have:

1. A Ledger hardware wallet
2. Ledger Live application installed on your computer
3. Your Ledger device initialized with a recovery phrase
4. Latest firmware installed on your Ledger device
5. A Chromium-based browser (e.g., Google Chrome, Brave, Microsoft Edge, or Chromium)
6. SubWallet extension installed

:::warning

**Important Security Notes:**
- Never share your 24-word recovery phrase with anyone
- Always verify addresses and transactions on your Ledger device screen before signing
- Keep your Ledger device firmware up to date

:::

### 1. Install the Polkadot App on Your Ledger Device

1. Connect your Ledger device to your computer and unlock it with your PIN
2. Open **Ledger Live** on your computer
3. Navigate to **My Ledger** in the left sidebar
4. Search for **Polkadot** in the App catalog
5. Click **Install** to add the Polkadot app to your Ledger device
6. Wait for the installation to complete

### 2. Connect Your Ledger to SubWallet

To interact with Acurast using your Ledger, you'll connect it through SubWallet:

1. Make sure your Ledger device is connected to your computer and unlocked
2. Open the **Polkadot app** on your Ledger device (the screen should display "Polkadot ready")
3. Open the SubWallet extension in your browser
4. Click on the account selector at the top of the extension
5. Click **"Attach account"**
6. Select **"Connect a Ledger device"**
7. In the popup, select your Ledger device and click **"Connect"**
8. SubWallet will automatically detect and import your Ledger accounts
9. Select the account(s) you want to import and click **"Import"**
10. Your Ledger account is now connected to SubWallet

### 3. Enable Acurast Network in SubWallet

To view your Acurast balance and interact with the network:

1. Open the SubWallet extension
2. Click the **hamburger menu** (three horizontal lines) in the top left
3. Select **"Manage networks"** or **"Manage chains"**
4. In the search bar, type **"Acurast"**
5. Enable the Acurast network by toggling the switch next to it
   - For Mainnet: Enable **"Acurast"** (coming soon)
   - For Canary: Enable **"Acurast Canary"**
6. Close the network settings
7. Your Ledger account should now display your token balance (ACU for Mainnet or cACU for Canary) in the main view

### Get the address of your Acurast account

To copy your Acurast address from SubWallet:

1. Open the SubWallet extension
2. Make sure you have the Acurast network enabled (see section 3)
3. Select your Ledger account from the account list
4. Click on the account name or address to view account details
5. Click on your address or the **copy icon** to copy your Acurast address to the clipboard
6. Your address will be in the correct Acurast format

### Connect your Ledger account to the Acurast Hub

1. Connect your Ledger device and unlock it
2. Open the **Polkadot app** on your Ledger (it should display "Polkadot ready")
3. Go to [hub.acurast.com](https://hub.acurast.com/) and click **Enter Hub**
4. Click **Connect**
5. Select **SubWallet** as your wallet option
6. In the SubWallet extension popup, select your Ledger account
7. Click **Connect** or **Confirm** to authorize the connection
8. On the connection modal of the hub, the new account appears, click it to enter the hub
9. Your Ledger account is now connected to the Acurast Hub

### Signing Transactions with Ledger

When you make a transaction using SubWallet with your Ledger:

1. Initiate a transaction in the Acurast Hub or SubWallet extension
2. SubWallet will prompt you with a Signature Request to confirm the transaction
3. Make sure your Ledger device is connected and unlocked with the Polkadot app open
4. In SubWallet make sure the correct account is selected and click **"Approve"** (with the ledger symbol)
5. Your Ledger device will display the transaction details for review
6. **Carefully verify** the transaction information on your Ledger screen:
   - Transaction type
   - Amount (if applicable)
   - Destination address
   - Fees
6. Use the buttons on your Ledger to navigate through the transaction details
7. If everything is correct, approve the transaction on your Ledger device by pressing both buttons
8. SubWallet will process the signed transaction and broadcast it to the Acurast network

### Troubleshooting

**Ledger not detected:**
- Make sure your Ledger device is unlocked and the Polkadot app is open
- Try a different USB cable or port
- Ensure Ledger Live is closed (it can interfere with browser access)

**Transaction fails:**
- Verify you have sufficient token balance for transaction fees (cACU for Canary or ACU for Mainnet)
- Make sure your Ledger firmware is up to date
- Check that the Polkadot app on your Ledger is the latest version

### Additional Resources

- [Ledger Official Support](https://support.ledger.com/)
- [Polkadot on Ledger Guide](https://support.ledger.com/hc/en-us/articles/360016289919)

---

## SubWallet

This guide explains how to create an address with [SubWallet](https://www.subwallet.app/). SubWallet is a comprehensive non-custodial wallet for Polkadot, Substrate, and Ethereum ecosystems.

:::info

SubWallet is the recommended wallet for Acurast due to its excellent support for Polkadot parachains and user-friendly interface. It's available as a browser extension and mobile app.

:::

## 1. Install SubWallet

### Browser Extension

1. Visit the official SubWallet website: [www.subwallet.app](https://www.subwallet.app/)
2. Click **"Download"** and select your browser (Chrome, Firefox, Brave, or Edge)
3. You'll be redirected to your browser's extension store
4. Click **"Add to [Browser]"** to install the extension
5. Pin the extension to your browser toolbar for easy access

### Mobile App

1. Download SubWallet from:
   - **iOS**: [Apple App Store](https://apps.apple.com/us/app/subwallet-polkadot-wallet/id1633050285)
   - **Android**: [Google Play Store](https://play.google.com/store/apps/details?id=app.subwallet.mobile)
2. Install and open the app

## 2. Create a New Wallet

When you first open SubWallet:

1. Click **"Create a new account"**
2. SubWallet will generate a recovery phrase (seed phrase) for you
3. **Write down your recovery phrase** and store it securely offline
4. Confirm your recovery phrase by selecting the words in the correct order
5. Create a strong master password for your wallet
6. Click **"Continue"** to complete the setup

:::danger IMPORTANT

Your recovery phrase is the master key to your wallet. Anyone with access to it can access your funds. Never share it, and keep multiple secure backups.

:::

## 3. Enable Acurast Network

To use Acurast with SubWallet, you need to enable the Acurast network:

1. Open the SubWallet extension or app
2. Click the **hamburger menu** (three horizontal lines) in the top left
3. Select **"Manage networks"** or **"Manage chains"**
4. In the search bar, type **"Acurast"**
5. Enable the Acurast network by toggling the switch:
   - For Mainnet: Enable **"Acurast"** (coming soon)
   - For Canary: Enable **"Acurast Canary"**
6. Close the network settings

Your SubWallet will now display your Acurast balance and allow you to interact with the Acurast network.

## 4. Get Your Acurast Address

To receive Acurast tokens, you'll need your Acurast address:

1. Open the SubWallet extension or app
2. Make sure you have the Acurast network enabled
3. Your main account view will show your balance
4. Click on the account name or address to view details
5. Click on your address or the **copy icon** to copy your Acurast address
6. Your address will be copied to the clipboard in the correct Acurast format

You can now share this address to receive ACU (Mainnet) or cACU (Canary) tokens.

## 5. Connect SubWallet to the Acurast Hub

To interact with the Acurast Hub using SubWallet:

1. Go to [hub.acurast.com](https://hub.acurast.com/) and click **Enter Hub**
2. Click **Connect**
3. Select **SubWallet** from the list of available wallets
4. In the SubWallet extension popup, review the connection request
5. Select the account(s) you want to connect to the hub
6. Click **Connect** or **Approve**
7. On the connection modal of the hub, your account will appear
8. Click on your account to enter the hub

You are now connected and can manage your Acurast deployments and processor operations.

## Troubleshooting

### SubWallet not connecting to Acurast Hub

- Make sure you have the Acurast network enabled in SubWallet
- Try refreshing the hub page
- Check that the SubWallet extension is unlocked
- Try to reconnect it to the hub, by clicking the connector icon next to your account
- Clear your browser cache and try again

### Balance not showing

- Verify that you've enabled the Acurast network in SubWallet settings
- Check that you're looking at the correct account
- Try switching networks and switching back to Acurast
- Wait a few moments for the network to sync

## Additional Resources

- [SubWallet Official Website](https://www.subwallet.app/)
- [SubWallet Documentation](https://docs.subwallet.app/)
- [SubWallet Support](https://docs.subwallet.app/main/support)
- [Acurast Hub](https://hub.acurast.com/)

---

## Talisman

This guide explains how to create an address with [Talisman](https://talisman.xyz/) wallet. To install the browser extensions, follow their setup instructions.

:::info

Most wallets allow you to create a generic polkadot address that is supported by Acurast, this guide focuses on the Talisman wallet.

:::

## 1. Create an Acurast address with Talisman

Once you created your recovery phrase follow these steps to create an Acurast address:

1. Open the settings menu (more) in your Talisman browser extension and select *Add Account*
2. Choose *New Polkadot Account*.

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/new_talisman.png"),
    dark: useBaseUrl("/guide/talisman/new_talisman.png"),
  }}
/>

3. Select the Recovery Phrase to use and give your Account a name, eg "Acurast", then click *Create*

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/create_talisman.png"),
    dark: useBaseUrl("/guide/talisman/create_talisman.png"),
  }}
/>

4. In order to display Acurast tokens, go to *Networks & Tokens* in the Settings menu and select *Manage Networks*. Then click *+ Add network*

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/addnetwork_talisman.png"),
    dark: useBaseUrl("/guide/talisman/addnetwork_talisman.png"),
  }}
/>

5. Select *Polkadot* as platform, then enter the following data:

For Acurast Canary:

RPC Url: **`wss://public-rpc.canary.acurast.com`**  
Native Token Symbol: **`cACU`**    
Native Token Decimals: **`12`**    
Native Token Name: **`cACU`**    
Display Balances: **`Yes`**   

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/network_talisman.png"),
    dark: useBaseUrl("/guide/talisman/network_talisman.png"),
  }}
/>

6. Your Acurast Account on Talisman is now ready to be used and to sign transactions

## 2. Get the address of your Acurast account on Talisman

Open your Talisman browser extension and select the Acurast account. Then click on the copy&paste symbol on top right and your Acurast account address will be copied into the clipboard. 

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/getaddress_talisman.png"),
    dark: useBaseUrl("/guide/talisman/getaddress_talisman.png"),
  }}
/>

## 3. Connect your Talisman account to the Acurast Hub

1. Go to [hub.acurast.com](https://hub.acurast.com/) and click *Enter Hub*
2. Click *Connect*
3. Open your Talisman browser extension
4. On top of your Talisman extension, select the account you want to connect to hub.acurast.com

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/hub_talisman.png"),
    dark: useBaseUrl("/guide/talisman/hub_talisman.png"),
  }}
/>

Select it and the bullet point will turn green:

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/selectacc_talisman.png"),
    dark: useBaseUrl("/guide/talisman/selectacc_talisman.png"),
  }}
/>

5. Go back to the hub.acurast.com page and click *Talisman*. The account will now appear under *Select Account*. Click it

<ThemedImage
  sources={{
    light: useBaseUrl("/guide/talisman/selacc_talisman.png"),
    dark: useBaseUrl("/guide/talisman/selacc_talisman.png"),
  }}
/>

6. You are now connected to hub.acurast.com
